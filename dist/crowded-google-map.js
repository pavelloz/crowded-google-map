(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("crowded-google-map", [], factory);
	else if(typeof exports === 'object')
		exports["crowded-google-map"] = factory();
	else
		root["crowded-google-map"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/node-js-marker-clusterer/src/markerclusterer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-js-marker-clusterer/src/markerclusterer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Npm version of markerClusterer works great with browserify and google maps for commonjs\n * https://www.npmjs.com/package/googlemaps\n * Difference from the original - adds a commonjs format and replaces window with global and some unit test\n * The original functionality it's not modified for docs and original source check\n * https://github.com/googlemaps/js-marker-clusterer\n */\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n * <br/>\n * This is a v3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >v2 MarkerClusterer</a>.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'averageCenter': (boolean) Wether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] ||\n      this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] ||\n      this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    var zoom = that.map_.getZoom();\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && opt_markers.length) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =\n    'http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/' +\n    'images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return (function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    this.pushMarkerTo_(marker);\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n   return false;\n  }\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  var removed = false;\n\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n      this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n      markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {number} The cluster center.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {Array.<google.maps.Marker>} The cluster center.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function() {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function() {\n    that.triggerClusterClick();\n  });\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n  }\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n        this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) +\n          'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n          'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n        this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) +\n          'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' +\n        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nglobal['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n    MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n    MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n    MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n    MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n    MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n    MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n    MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n    MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n    MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n    MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n    MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n    MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n    MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n    MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\n\nmodule.exports = MarkerClusterer;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/node-js-marker-clusterer/src/markerclusterer.js\n// module id = ./node_modules/node-js-marker-clusterer/src/markerclusterer.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/./node_modules/node-js-marker-clusterer/src/markerclusterer.js?");

/***/ }),

/***/ "./node_modules/object-assign-deep/objectAssignDeep.js":
/*!*************************************************************!*\
  !*** ./node_modules/object-assign-deep/objectAssignDeep.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n * OBJECT ASSIGN DEEP\n * Allows deep cloning of plain objects that contain primitives, nested plain objects, or nested plain arrays.\n */\n\n/*\n * A unified way of returning a string that describes the type of the given variable.\n */\nfunction getTypeOf (input) {\n\n\tif (input === null) {\n\t\treturn `null`;\n\t}\n\n\telse if (typeof input === `undefined`) {\n\t\treturn `undefined`;\n\t}\n\n\telse if (typeof input === `object`) {\n\t\treturn (Array.isArray(input) ? `array` : `object`);\n\t}\n\n\treturn typeof input;\n\n}\n\n/*\n * Branching logic which calls the correct function to clone the given value base on its type.\n */\nfunction cloneValue (value) {\n\n\t// The value is an object so lets clone it.\n\tif (getTypeOf(value) === `object`) {\n\t\treturn quickCloneObject(value);\n\t}\n\n\t// The value is an array so lets clone it.\n\telse if (getTypeOf(value) === `array`) {\n\t\treturn quickCloneArray(value);\n\t}\n\n\t// Any other value can just be copied.\n\treturn value;\n\n}\n\n/*\n * Enumerates the given array and returns a new array, with each of its values cloned (i.e. references broken).\n */\nfunction quickCloneArray (input) {\n\treturn input.map(cloneValue);\n}\n\n/*\n * Enumerates the properties of the given object (ignoring the prototype chain) and returns a new object, with each of\n * its values cloned (i.e. references broken).\n */\nfunction quickCloneObject (input) {\n\n\tconst output = {};\n\n\tfor (const key in input) {\n\t\tif (!input.hasOwnProperty(key)) { continue; }\n\n\t\toutput[key] = cloneValue(input[key]);\n\t}\n\n\treturn output;\n\n}\n\n/*\n * Does the actual deep merging.\n */\nfunction executeDeepMerge (target, _objects = [], _options = {}) {\n\n\tconst options = {\n\t\tarrayBehaviour: _options.arrayBehaviour || `replace`,  // Can be \"merge\" or \"replace\".\n\t};\n\n\t// Ensure we have actual objects for each.\n\tconst objects = _objects.map(object => object || {});\n\n\tconst output = target || {};\n\n\t// Enumerate the objects and their keys.\n\tfor (let oindex = 0; oindex < objects.length; oindex++) {\n\t\tconst object = objects[oindex];\n\t\tconst keys = Object.keys(object);\n\n\t\tfor (let kindex = 0; kindex < keys.length; kindex++) {\n\t\t\tconst key = keys[kindex];\n\t\t\tconst value = object[key];\n\t\t\tconst type = getTypeOf(value);\n\t\t\tconst existingValueType = getTypeOf(output[key]);\n\n\t\t\tif (type === `object`) {\n\t\t\t\tif (existingValueType !== `undefined`) {\n\t\t\t\t\tconst existingValue = (existingValueType === `object` ? output[key] : {});\n\t\t\t\t\toutput[key] = executeDeepMerge({}, [existingValue, quickCloneObject(value)], options);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[key] = quickCloneObject(value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (type === `array`) {\n\t\t\t\tif (existingValueType === `array`) {\n\t\t\t\t\tconst newValue = quickCloneArray(value);\n\t\t\t\t\toutput[key] = (options.arrayBehaviour === `merge` ? output[key].concat(newValue) : newValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[key] = quickCloneArray(value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\toutput[key] = value;\n\t\t\t}\n\n\n\t\t}\n\t}\n\n\treturn output;\n\n}\n\n/*\n * Merge all the supplied objects into the target object, breaking all references, including those of nested objects\n * and arrays, and even objects nested inside arrays. The first parameter is not mutated unlike Object.assign().\n * Properties in later objects will always overwrite.\n */\nmodule.exports = function objectAssignDeep (target, ...objects) {\n\treturn executeDeepMerge(target, objects);\n};\n\n/*\n * Same as objectAssignDeep() except it doesn't mutate the target object and returns an entirely new object.\n */\nmodule.exports.noMutate = function objectAssignDeepInto (...objects) {\n\treturn executeDeepMerge({}, objects);\n};\n\n/*\n * Allows an options object to be passed in to customise the behaviour of the function.\n */\nmodule.exports.withOptions = function objectAssignDeepInto (target, objects, options) {\n\treturn executeDeepMerge(target, objects, options);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/object-assign-deep/objectAssignDeep.js\n// module id = ./node_modules/object-assign-deep/objectAssignDeep.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/./node_modules/object-assign-deep/objectAssignDeep.js?");

/***/ }),

/***/ "./node_modules/overlapping-marker-spiderfier/lib/oms.js":
/*!***************************************************************!*\
  !*** ./node_modules/overlapping-marker-spiderfier/lib/oms.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.10.0\n\n/** @preserve OverlappingMarkerSpiderfier\nhttps://github.com/jawj/OverlappingMarkerSpiderfier\nCopyright (c) 2011 - 2013 George MacKerron\nReleased under the MIT licence: http://opensource.org/licenses/mit-license\nNote: The Google Maps API v3 must be included *before* this code\n */\nvar hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\nthis['OverlappingMarkerSpiderfier'] = (function() {\n  var ge, gm, lcH, lcU, mt, p, twoPi;\n\n  p = _Class.prototype;\n\n  gm = google.maps;\n\n  ge = gm.event;\n\n  mt = gm.MapTypeId;\n\n  twoPi = Math.PI * 2;\n\n  p['keepSpiderfied'] = false;\n\n  p['markersWontHide'] = false;\n\n  p['markersWontMove'] = false;\n\n  p['spiderfiedShadowColor'] = 'white';\n\n  p['nudgeStackedMarkers'] = true;\n\n  p['minNudgeZoomLevel'] = 8;\n\n  p['nudgeRadius'] = 1;\n\n  p['markerCountInBaseNudgeLevel'] = 9;\n\n  p['maxNudgeCount'] = 9;\n\n  p['nudgeBucketSize'] = 12;\n\n  p['nearbyDistance'] = 20;\n\n  p['circleSpiralSwitchover'] = 9;\n\n  p['circleFootSeparation'] = 23;\n\n  p['circleStartAngle'] = twoPi / 12;\n\n  p['spiralFootSeparation'] = 26;\n\n  p['spiralLengthStart'] = 11;\n\n  p['spiralLengthFactor'] = 4;\n\n  p['spiderfiedZIndex'] = 1000;\n\n  p['usualLegZIndex'] = 10;\n\n  p['highlightedLegZIndex'] = 20;\n\n  p['event'] = 'click';\n\n  p['minZoomLevel'] = false;\n\n  p['lineToCenter'] = true;\n\n  p['legWeight'] = 1.5;\n\n  p['legColors'] = {\n    'usual': {},\n    'highlighted': {}\n  };\n\n  lcU = p['legColors']['usual'];\n\n  lcH = p['legColors']['highlighted'];\n\n  lcU[mt.HYBRID] = lcU[mt.SATELLITE] = '#fff';\n\n  lcH[mt.HYBRID] = lcH[mt.SATELLITE] = '#f00';\n\n  lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = '#444';\n\n  lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = '#f00';\n\n  function _Class(map1, opts) {\n    var e, j, k, len, ref, v;\n    this.map = map1;\n    if (opts == null) {\n      opts = {};\n    }\n    for (k in opts) {\n      if (!hasProp.call(opts, k)) continue;\n      v = opts[k];\n      this[k] = v;\n    }\n    this.projHelper = new this.constructor.ProjHelper(this.map);\n    this.initMarkerArrays();\n    this.listeners = {};\n    ref = ['click', 'zoom_changed', 'maptypeid_changed'];\n    for (j = 0, len = ref.length; j < len; j++) {\n      e = ref[j];\n      ge.addListener(this.map, e, (function(_this) {\n        return function() {\n          return _this['unspiderfy']();\n        };\n      })(this));\n    }\n    if (this['nudgeStackedMarkers']) {\n      ge.addListenerOnce(this.map, 'idle', (function(_this) {\n        return function() {\n          ge.addListener(_this.map, 'zoom_changed', function() {\n            return _this.mapZoomChangeListener();\n          });\n          return _this.mapZoomChangeListener();\n        };\n      })(this));\n    }\n  }\n\n  p.initMarkerArrays = function() {\n    this.markers = [];\n    return this.markerListenerRefs = [];\n  };\n\n  p['addMarker'] = function(marker) {\n    var listenerRefs;\n    if (marker['_oms'] != null) {\n      return this;\n    }\n    marker['_oms'] = true;\n    listenerRefs = [\n      ge.addListener(marker, this['event'], (function(_this) {\n        return function(event) {\n          return _this.spiderListener(marker, event);\n        };\n      })(this))\n    ];\n    if (!this['markersWontHide']) {\n      listenerRefs.push(ge.addListener(marker, 'visible_changed', (function(_this) {\n        return function() {\n          return _this.markerChangeListener(marker, false);\n        };\n      })(this)));\n    }\n    if (!this['markersWontMove']) {\n      listenerRefs.push(ge.addListener(marker, 'position_changed', (function(_this) {\n        return function() {\n          return _this.markerChangeListener(marker, true);\n        };\n      })(this)));\n    }\n    this.markerListenerRefs.push(listenerRefs);\n    this.markers.push(marker);\n    if (this.isNudgingActive()) {\n      this.requestNudge();\n    }\n    return this;\n  };\n\n  p.nudgeTimeout = null;\n\n  p.requestNudge = function() {\n    if (this.nudgeTimeout) {\n      clearTimeout(this.nudgeTimeout);\n    }\n    return this.nudgeTimeout = setTimeout((function(_this) {\n      return function() {\n        return _this.nudgeAllMarkers();\n      };\n    })(this), 10);\n  };\n\n  p.isNudgingActive = function() {\n    return this['nudgeStackedMarkers'] && !(this['minNudgeZoomLevel'] && this.map.getZoom() < this['minNudgeZoomLevel']) && !this.spiderfied;\n  };\n\n  p.markerChangeListener = function(marker, positionChanged) {\n    if ((marker['_omsData'] != null) && marker['_omsData'].leg && (positionChanged || !marker.getVisible()) && !((this.spiderfying != null) || (this.unspiderfying != null))) {\n      return this['unspiderfy'](positionChanged ? marker : null);\n    }\n  };\n\n  p.countsPerLevel = [1, 1];\n\n  p.levelsByCount = [];\n\n  p.getCountPerNudgeLevel = function(level) {\n    if (this.countsPerLevel[level] != null) {\n      return this.countsPerLevel[level];\n    }\n    this.countsPerLevel[level] = this.getCountPerNudgeLevel(level - 1) + Math.pow(2, level - 2) * this['markerCountInBaseNudgeLevel'];\n    return this.countsPerLevel[level];\n  };\n\n  p.getNudgeLevel = function(markerIndex) {\n    var level;\n    if (this.levelsByCount[markerIndex] != null) {\n      return this.levelsByCount[markerIndex];\n    }\n    level = 0;\n    while (markerIndex >= this.countsPerLevel[level]) {\n      if (level + 1 >= this.countsPerLevel.length) {\n        this.getCountPerNudgeLevel(level + 1);\n      }\n      level++;\n    }\n    this.levelsByCount[markerIndex] = level - 1;\n    return this.levelsByCount[markerIndex];\n  };\n\n  p.nudgeAllMarkers = function() {\n    var bucketSize, changeX, changeY, changesX, changesY, count, getHash, j, len, m, needsNudge, originalPos, pos, posHash, positions, ref, ref1, ref2, ref3, ref4, ref5, results, ringLevel;\n    if (!this.isNudgingActive()) {\n      return;\n    }\n    positions = {};\n    changesX = [];\n    changesY = [];\n    bucketSize = 1 / ((1 + this['nudgeBucketSize']) * this['nudgeRadius']);\n    getHash = (function(_this) {\n      return function(pos) {\n        return Math.floor(pos.x * bucketSize) + ',' + Math.floor(pos.y * bucketSize);\n      };\n    })(this);\n    ref = this.markers;\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n      m = ref[j];\n      needsNudge = false;\n      pos = this.llToPt((ref1 = (ref2 = m['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : m.position);\n      originalPos = {\n        x: pos.x,\n        y: pos.y\n      };\n      posHash = getHash(pos);\n      while ((positions[posHash] != null) && ((this['maxNudgeCount'] == null) || positions[posHash] <= this['maxNudgeCount'])) {\n        count = positions[posHash];\n        positions[posHash] += 1;\n        if (changesX[count] != null) {\n          changeX = changesX[count];\n          changeY = changesY[count];\n        } else {\n          ringLevel = this.getNudgeLevel(count);\n          changesX[count] = changeX = Math.sin(twoPi * count / this['markerCountInBaseNudgeLevel'] / ringLevel) * 20 * this['nudgeRadius'] * ringLevel;\n          changesY[count] = changeY = Math.cos(twoPi * count / this['markerCountInBaseNudgeLevel'] / ringLevel) * 20 * this['nudgeRadius'] * ringLevel;\n        }\n        pos.x = originalPos.x + changeX;\n        pos.y = originalPos.y + changeY;\n        this.nudged = true;\n        needsNudge = true;\n        posHash = getHash(pos);\n      }\n      if (needsNudge) {\n        m['_omsData'] = (ref3 = m['_omsData']) != null ? ref3 : {};\n        m['_omsData'].usualPosition = (ref4 = (ref5 = m['_omsData']) != null ? ref5.usualPosition : void 0) != null ? ref4 : m.position;\n        m.setPosition(this.ptToLl(pos));\n      } else if ((m['_omsData'] != null) && (m['_omsData'].leg == null)) {\n        m.setPosition(m['_omsData'].usualPosition);\n        delete m['_omsData'];\n      }\n      if (!(posHash in positions)) {\n        results.push(positions[posHash] = 1);\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  p.resetNudgedMarkers = function() {\n    var j, len, m, ref;\n    if (!this.nudged) {\n      return;\n    }\n    ref = this.markers;\n    for (j = 0, len = ref.length; j < len; j++) {\n      m = ref[j];\n      if ((m['_omsData'] != null) && (m['_omsData'].leg == null)) {\n        m.setPosition(m['_omsData'].usualPosition);\n        delete m['_omsData'];\n      }\n    }\n    return delete this.nudged;\n  };\n\n  p.mapZoomChangeListener = function() {\n    if (this['minNudgeZoomLevel'] && this.map.getZoom() < this['minNudgeZoomLevel']) {\n      return this.resetNudgedMarkers();\n    }\n    return this.requestNudge();\n  };\n\n  p['getMarkers'] = function() {\n    return this.markers.slice(0);\n  };\n\n  p['removeMarker'] = function(marker) {\n    var i, j, len, listenerRef, listenerRefs;\n    if (marker['_omsData'] != null) {\n      this['unspiderfy']();\n    }\n    i = this.arrIndexOf(this.markers, marker);\n    if (i < 0) {\n      return this;\n    }\n    listenerRefs = this.markerListenerRefs.splice(i, 1)[0];\n    for (j = 0, len = listenerRefs.length; j < len; j++) {\n      listenerRef = listenerRefs[j];\n      ge.removeListener(listenerRef);\n    }\n    delete marker['_oms'];\n    this.markers.splice(i, 1);\n    if (this.isNudgingActive()) {\n      this.requestNudge();\n    }\n    return this;\n  };\n\n  p['clearMarkers'] = function() {\n    var i, j, l, len, len1, listenerRef, listenerRefs, marker, ref;\n    this['unspiderfy']();\n    ref = this.markers;\n    for (i = j = 0, len = ref.length; j < len; i = ++j) {\n      marker = ref[i];\n      listenerRefs = this.markerListenerRefs[i];\n      for (l = 0, len1 = listenerRefs.length; l < len1; l++) {\n        listenerRef = listenerRefs[l];\n        ge.removeListener(listenerRef);\n      }\n      delete marker['_oms'];\n    }\n    this.initMarkerArrays();\n    return this;\n  };\n\n  p['addListener'] = function(event, func) {\n    var base;\n    ((base = this.listeners)[event] != null ? base[event] : base[event] = []).push(func);\n    return this;\n  };\n\n  p['removeListener'] = function(event, func) {\n    var i;\n    i = this.arrIndexOf(this.listeners[event], func);\n    if (!(i < 0)) {\n      this.listeners[event].splice(i, 1);\n    }\n    return this;\n  };\n\n  p['clearListeners'] = function(event) {\n    this.listeners[event] = [];\n    return this;\n  };\n\n  p.trigger = function() {\n    var args, event, func, j, len, ref, ref1, results;\n    event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    ref1 = (ref = this.listeners[event]) != null ? ref : [];\n    results = [];\n    for (j = 0, len = ref1.length; j < len; j++) {\n      func = ref1[j];\n      results.push(func.apply(null, args));\n    }\n    return results;\n  };\n\n  p.generatePtsCircle = function(count, centerPt) {\n    var angle, angleStep, circumference, i, j, legLength, ref, results;\n    circumference = this['circleFootSeparation'] * (2 + count);\n    legLength = circumference / twoPi;\n    angleStep = twoPi / count;\n    results = [];\n    for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      angle = this['circleStartAngle'] + i * angleStep;\n      results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));\n    }\n    return results;\n  };\n\n  p.generatePtsSpiral = function(count, centerPt) {\n    var angle, i, j, legLength, pt, ref, results;\n    legLength = this['spiralLengthStart'];\n    angle = 0;\n    results = [];\n    for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      angle += this['spiralFootSeparation'] / legLength + i * 0.0005;\n      pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));\n      legLength += twoPi * this['spiralLengthFactor'] / angle;\n      results.push(pt);\n    }\n    return results;\n  };\n\n  p.spiderListener = function(marker, event) {\n    var j, len, m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, ref;\n    markerSpiderfied = (marker['_omsData'] != null) && (marker['_omsData'].leg != null);\n    if (!(markerSpiderfied && this['keepSpiderfied'])) {\n      if (this['event'] === 'mouseover') {\n        window.clearTimeout(p.timeout);\n        p.timeout = setTimeout((function(_this) {\n          return function() {\n            return _this['unspiderfy']();\n          };\n        })(this), 3000);\n      } else {\n        this['unspiderfy']();\n      }\n    }\n    if (markerSpiderfied || this.map.getStreetView().getVisible() || this.map.getMapTypeId() === 'GoogleEarthAPI' || this['minZoomLevel'] && this.map.getZoom() < this['minZoomLevel']) {\n      return this.trigger('click', marker, event);\n    } else {\n      nearbyMarkerData = [];\n      nonNearbyMarkers = [];\n      nDist = this['nearbyDistance'];\n      pxSq = nDist * nDist;\n      markerPt = this.llToPt(marker.position);\n      ref = this.markers;\n      for (j = 0, len = ref.length; j < len; j++) {\n        m = ref[j];\n        if (!((m.map != null) && m.getVisible())) {\n          continue;\n        }\n        mPt = this.llToPt(m.position);\n        if (this.ptDistanceSq(mPt, markerPt) < pxSq) {\n          nearbyMarkerData.push({\n            marker: m,\n            markerPt: mPt\n          });\n        } else {\n          nonNearbyMarkers.push(m);\n        }\n      }\n      if (nearbyMarkerData.length === 1) {\n        return this.trigger('click', marker, event);\n      } else {\n        return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);\n      }\n    }\n  };\n\n  p['markersNearMarker'] = function(marker, firstOnly) {\n    var j, len, m, mPt, markerPt, markers, nDist, pxSq, ref, ref1, ref2;\n    if (firstOnly == null) {\n      firstOnly = false;\n    }\n    if (this.projHelper.getProjection() == null) {\n      throw \"Must wait for 'idle' event on map before calling markersNearMarker\";\n    }\n    nDist = this['nearbyDistance'];\n    pxSq = nDist * nDist;\n    markerPt = this.llToPt(marker.position);\n    markers = [];\n    ref = this.markers;\n    for (j = 0, len = ref.length; j < len; j++) {\n      m = ref[j];\n      if (m === marker || (m.map == null) || !m.getVisible()) {\n        continue;\n      }\n      mPt = this.llToPt((ref1 = (ref2 = m['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : m.position);\n      if (this.ptDistanceSq(mPt, markerPt) < pxSq) {\n        markers.push(m);\n        if (firstOnly) {\n          break;\n        }\n      }\n    }\n    return markers;\n  };\n\n  p['markersNearAnyOtherMarker'] = function() {\n    var i, i1, i2, j, l, len, len1, len2, m, m1, m1Data, m2, m2Data, mData, n, nDist, pxSq, ref, ref1, ref2, results;\n    if (this.projHelper.getProjection() == null) {\n      throw \"Must wait for 'idle' event on map before calling markersNearAnyOtherMarker\";\n    }\n    nDist = this['nearbyDistance'];\n    pxSq = nDist * nDist;\n    mData = (function() {\n      var j, len, ref, ref1, ref2, results;\n      ref = this.markers;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        m = ref[j];\n        results.push({\n          pt: this.llToPt((ref1 = (ref2 = m['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : m.position),\n          willSpiderfy: false\n        });\n      }\n      return results;\n    }).call(this);\n    ref = this.markers;\n    for (i1 = j = 0, len = ref.length; j < len; i1 = ++j) {\n      m1 = ref[i1];\n      if (!((m1.map != null) && m1.getVisible())) {\n        continue;\n      }\n      m1Data = mData[i1];\n      if (m1Data.willSpiderfy) {\n        continue;\n      }\n      ref1 = this.markers;\n      for (i2 = l = 0, len1 = ref1.length; l < len1; i2 = ++l) {\n        m2 = ref1[i2];\n        if (i2 === i1) {\n          continue;\n        }\n        if (!((m2.map != null) && m2.getVisible())) {\n          continue;\n        }\n        m2Data = mData[i2];\n        if (i2 < i1 && !m2Data.willSpiderfy) {\n          continue;\n        }\n        if (this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {\n          m1Data.willSpiderfy = m2Data.willSpiderfy = true;\n          break;\n        }\n      }\n    }\n    ref2 = this.markers;\n    results = [];\n    for (i = n = 0, len2 = ref2.length; n < len2; i = ++n) {\n      m = ref2[i];\n      if (mData[i].willSpiderfy) {\n        results.push(m);\n      }\n    }\n    return results;\n  };\n\n  p.makeHighlightListenerFuncs = function(marker) {\n    return {\n      highlight: (function(_this) {\n        return function() {\n          var icon;\n          marker['_omsData'].leg.setOptions({\n            strokeColor: _this['legColors']['highlighted'][_this.map.mapTypeId],\n            zIndex: _this['highlightedLegZIndex']\n          });\n          if (marker['_omsData'].shadow != null) {\n            icon = marker['_omsData'].shadow.getIcon();\n            icon.fillOpacity = 0.8;\n            return marker['_omsData'].shadow.setOptions({\n              icon: icon\n            });\n          }\n        };\n      })(this),\n      unhighlight: (function(_this) {\n        return function() {\n          var icon;\n          marker['_omsData'].leg.setOptions({\n            strokeColor: _this['legColors']['usual'][_this.map.mapTypeId],\n            zIndex: _this['usualLegZIndex']\n          });\n          if (marker['_omsData'].shadow != null) {\n            icon = marker['_omsData'].shadow.getIcon();\n            icon.fillOpacity = 0.3;\n            return marker['_omsData'].shadow.setOptions({\n              icon: icon\n            });\n          }\n        };\n      })(this)\n    };\n  };\n\n  p.spiderfy = function(markerData, nonNearbyMarkers) {\n    var bodyPt, centerLl, footLl, footPt, footPts, highlightListenerFuncs, leg, lineOrigin, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;\n    this.spiderfying = true;\n    numFeet = markerData.length;\n    bodyPt = this.ptAverage((function() {\n      var j, len, results;\n      results = [];\n      for (j = 0, len = markerData.length; j < len; j++) {\n        md = markerData[j];\n        results.push(md.markerPt);\n      }\n      return results;\n    })());\n    footPts = numFeet >= this['circleSpiralSwitchover'] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);\n    centerLl = this.ptToLl(bodyPt);\n    spiderfiedMarkers = (function() {\n      var j, len, ref, ref1, ref2, results;\n      results = [];\n      for (j = 0, len = footPts.length; j < len; j++) {\n        footPt = footPts[j];\n        footLl = this.ptToLl(footPt);\n        nearestMarkerDatum = this.minExtract(markerData, (function(_this) {\n          return function(md) {\n            return _this.ptDistanceSq(md.markerPt, footPt);\n          };\n        })(this));\n        marker = nearestMarkerDatum.marker;\n        lineOrigin = this['lineToCenter'] ? centerLl : marker.position;\n        leg = new gm.Polyline({\n          map: this.map,\n          path: [lineOrigin, footLl],\n          strokeColor: this['legColors']['usual'][this.map.mapTypeId],\n          strokeWeight: this['legWeight'],\n          zIndex: this['usualLegZIndex']\n        });\n        marker['_omsData'] = (ref = marker['_omsData']) != null ? ref : {};\n        marker['_omsData'].usualPosition = (ref1 = (ref2 = marker['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : marker.position;\n        marker['_omsData'].leg = leg;\n        if (this['spiderfiedShadowColor']) {\n          marker['_omsData'].shadow = new gm.Marker({\n            position: footLl,\n            map: this.map,\n            clickable: false,\n            zIndex: -2,\n            icon: {\n              path: google.maps.SymbolPath.CIRCLE,\n              fillOpacity: 0.3,\n              fillColor: this['spiderfiedShadowColor'],\n              strokeWeight: 0,\n              scale: 20\n            }\n          });\n        }\n        if (this['legColors']['highlighted'][this.map.mapTypeId] !== this['legColors']['usual'][this.map.mapTypeId]) {\n          highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);\n          marker['_omsData'].hightlightListeners = {\n            highlight: ge.addListener(marker, 'mouseover', highlightListenerFuncs.highlight),\n            unhighlight: ge.addListener(marker, 'mouseout', highlightListenerFuncs.unhighlight)\n          };\n        }\n        marker.setPosition(footLl);\n        marker.setZIndex(Math.round(this['spiderfiedZIndex'] + footPt.y));\n        results.push(marker);\n      }\n      return results;\n    }).call(this);\n    delete this.spiderfying;\n    this.spiderfied = true;\n    return this.trigger('spiderfy', spiderfiedMarkers, nonNearbyMarkers);\n  };\n\n  p['unspiderfy'] = function(markerNotToMove) {\n    var j, len, listeners, marker, nonNearbyMarkers, ref, ref1, unspiderfiedMarkers;\n    if (markerNotToMove == null) {\n      markerNotToMove = null;\n    }\n    if (!((this.spiderfied != null) || (this.nudged != null))) {\n      return this;\n    }\n    this.unspiderfying = true;\n    unspiderfiedMarkers = [];\n    nonNearbyMarkers = [];\n    ref = this.markers;\n    for (j = 0, len = ref.length; j < len; j++) {\n      marker = ref[j];\n      if ((marker['_omsData'] != null) && (marker['_omsData'].leg != null)) {\n        marker['_omsData'].leg.setMap(null);\n        if ((ref1 = marker['_omsData'].shadow) != null) {\n          ref1.setMap(null);\n        }\n        if (marker !== markerNotToMove) {\n          marker.setPosition(marker['_omsData'].usualPosition);\n        }\n        marker.setZIndex(null);\n        listeners = marker['_omsData'].hightlightListeners;\n        if (listeners != null) {\n          ge.removeListener(listeners.highlight);\n          ge.removeListener(listeners.unhighlight);\n        }\n        delete marker['_omsData'];\n        unspiderfiedMarkers.push(marker);\n      } else {\n        nonNearbyMarkers.push(marker);\n      }\n    }\n    delete this.unspiderfying;\n    delete this.spiderfied;\n    this.trigger('unspiderfy', unspiderfiedMarkers, nonNearbyMarkers);\n    if (this.nudged) {\n      this.requestNudge();\n    }\n    return this;\n  };\n\n  p.ptDistanceSq = function(pt1, pt2) {\n    var dx, dy;\n    dx = pt1.x - pt2.x;\n    dy = pt1.y - pt2.y;\n    return dx * dx + dy * dy;\n  };\n\n  p.ptAverage = function(pts) {\n    var j, len, numPts, pt, sumX, sumY;\n    sumX = sumY = 0;\n    for (j = 0, len = pts.length; j < len; j++) {\n      pt = pts[j];\n      sumX += pt.x;\n      sumY += pt.y;\n    }\n    numPts = pts.length;\n    return new gm.Point(sumX / numPts, sumY / numPts);\n  };\n\n  p.llToPt = function(ll) {\n    return this.projHelper.getProjection().fromLatLngToDivPixel(ll);\n  };\n\n  p.ptToLl = function(pt) {\n    return this.projHelper.getProjection().fromDivPixelToLatLng(pt);\n  };\n\n  p.minExtract = function(set, func) {\n    var bestIndex, bestVal, index, item, j, len, val;\n    for (index = j = 0, len = set.length; j < len; index = ++j) {\n      item = set[index];\n      val = func(item);\n      if ((typeof bestIndex === \"undefined\" || bestIndex === null) || val < bestVal) {\n        bestVal = val;\n        bestIndex = index;\n      }\n    }\n    return set.splice(bestIndex, 1)[0];\n  };\n\n  p.arrIndexOf = function(arr, obj) {\n    var i, j, len, o;\n    if (arr.indexOf != null) {\n      return arr.indexOf(obj);\n    }\n    for (i = j = 0, len = arr.length; j < len; i = ++j) {\n      o = arr[i];\n      if (o === obj) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  _Class.ProjHelper = function(map) {\n    return this.setMap(map);\n  };\n\n  _Class.ProjHelper.prototype = new gm.OverlayView();\n\n  _Class.ProjHelper.prototype['draw'] = function() {};\n\n  return _Class;\n\n})();\n\nmodule.exports = this['OverlappingMarkerSpiderfier'];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/overlapping-marker-spiderfier/lib/oms.js\n// module id = ./node_modules/overlapping-marker-spiderfier/lib/oms.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/./node_modules/overlapping-marker-spiderfier/lib/oms.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = ./node_modules/webpack/buildin/global.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/Markers.js":
/*!************************!*\
  !*** ./src/Markers.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _nodeJsMarkerClusterer = _interopRequireDefault(__webpack_require__(/*! node-js-marker-clusterer */ \"./node_modules/node-js-marker-clusterer/src/markerclusterer.js\"));\n\nvar _marker = _interopRequireDefault(__webpack_require__(/*! ./marker */ \"./src/marker.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Markers =\n/*#__PURE__*/\nfunction () {\n  function Markers(opts) {\n    _classCallCheck(this, Markers);\n\n    if (!opts || !opts.markersData || !opts.map) {\n      throw new Error('CrowdedGoogleMap :: Some required options are missing');\n      return;\n    }\n\n    this.get(opts).then(this.parse).then(this.create).then(this.cluster);\n  }\n\n  _createClass(Markers, [{\n    key: \"get\",\n    value: function get(opts) {\n      var isPromise = _typeof(opts.markersData) === 'object' && typeof opts.markersData.then === 'function';\n      var options;\n\n      if (isPromise) {\n        return opts.markersData.then(function (markers) {\n          return options = _extends({}, opts, {\n            markersData: markers\n          });\n        });\n      }\n\n      return opts;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(opts) {\n      return _extends({}, opts, {\n        markersData: opts.markersData.map(opts.parseMarkerData)\n      });\n    }\n  }, {\n    key: \"create\",\n    value: function create(opts) {\n      var oms = _marker.default.createSpiderify(opts);\n\n      return _extends({}, opts, {\n        markersData: opts.markersData.filter(_marker.default.valid).reduce(function (prev, marker) {\n          var googleMarker = _marker.default.create(marker);\n\n          var infoWindow = _marker.default.infoWindow(opts.infoWindowConfig(marker));\n\n          _marker.default.attachEventHandler(googleMarker, infoWindow, opts.map);\n\n          _marker.default.initializeSpiderify(oms, googleMarker);\n\n          return _toConsumableArray(prev).concat([googleMarker]);\n        }, [])\n      });\n    }\n  }, {\n    key: \"cluster\",\n    value: function cluster(_ref) {\n      var map = _ref.map,\n          markersData = _ref.markersData,\n          clustererConfig = _ref.clustererConfig;\n      return new _nodeJsMarkerClusterer.default(map, markersData, clustererConfig);\n    }\n  }]);\n\n  return Markers;\n}();\n\nvar _default = Markers;\nexports.default = _default;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Markers.js\n// module id = ./src/Markers.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/./src/Markers.js?");

/***/ }),

/***/ "./src/config/google-maps.js":
/*!***********************************!*\
  !*** ./src/config/google-maps.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  center: {\n    lat: -25.363,\n    lng: 131.044\n  },\n  zoom: 5\n};\nexports.default = _default;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/config/google-maps.js\n// module id = ./src/config/google-maps.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/./src/config/google-maps.js?");

/***/ }),

/***/ "./src/config/marker-clusterer.js":
/*!****************************************!*\
  !*** ./src/config/marker-clusterer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  gridSize: 50,\n  maxZoom: 14\n};\nexports.default = _default;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/config/marker-clusterer.js\n// module id = ./src/config/marker-clusterer.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/./src/config/marker-clusterer.js?");

/***/ }),

/***/ "./src/config/overlapping-marker-spiderifier.js":
/*!******************************************************!*\
  !*** ./src/config/overlapping-marker-spiderifier.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  markersWontMove: true,\n  markersWontHide: true,\n  circleFootSeparation: 65,\n  nearbyDistance: 32,\n  keepSpiderfied: true,\n  basicFormatEvents: true\n};\nexports.default = _default;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/config/overlapping-marker-spiderifier.js\n// module id = ./src/config/overlapping-marker-spiderifier.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/./src/config/overlapping-marker-spiderifier.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _objectAssignDeep = _interopRequireDefault(__webpack_require__(/*! object-assign-deep */ \"./node_modules/object-assign-deep/objectAssignDeep.js\"));\n\nvar _googleMaps = _interopRequireDefault(__webpack_require__(/*! ./config/google-maps */ \"./src/config/google-maps.js\"));\n\nvar _overlappingMarkerSpiderifier = _interopRequireDefault(__webpack_require__(/*! ./config/overlapping-marker-spiderifier */ \"./src/config/overlapping-marker-spiderifier.js\"));\n\nvar _markerClusterer = _interopRequireDefault(__webpack_require__(/*! ./config/marker-clusterer */ \"./src/config/marker-clusterer.js\"));\n\nvar _Markers = _interopRequireDefault(__webpack_require__(/*! ./Markers */ \"./src/Markers.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DEFAULTS = {\n  googleMapsConfig: _googleMaps.default,\n  clustererConfig: _markerClusterer.default,\n  spiderifyConfig: _overlappingMarkerSpiderifier.default,\n  activeInfoWindow: {\n    close: function close() {}\n  },\n  markersData: [],\n  infoWindowConfig: function infoWindowConfig(m) {\n    return m;\n  },\n  parseMarkerData: function parseMarkerData(m) {\n    return m;\n  }\n};\n\nvar CrowdedGoogleMap =\n/*#__PURE__*/\nfunction () {\n  function CrowdedGoogleMap(config) {\n    _classCallCheck(this, CrowdedGoogleMap);\n\n    var opts = (0, _objectAssignDeep.default)({}, DEFAULTS, config);\n\n    var options = _extends({}, opts, {\n      map: this.initialize(config.container, opts),\n      markersData: config.markersData\n    });\n\n    new _Markers.default(options);\n  }\n\n  _createClass(CrowdedGoogleMap, [{\n    key: \"initialize\",\n    value: function initialize(container, _ref) {\n      var googleMapsConfig = _ref.googleMapsConfig,\n          activeInfoWindow = _ref.activeInfoWindow;\n      return new google.maps.Map(container, {\n        center: googleMapsConfig.center,\n        zoom: googleMapsConfig.zoom,\n        activeInfoWindow: activeInfoWindow\n      });\n    }\n  }]);\n\n  return CrowdedGoogleMap;\n}();\n\nvar _default = CrowdedGoogleMap;\nexports.default = _default;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = ./src/index.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/./src/index.js?");

/***/ }),

/***/ "./src/marker.js":
/*!***********************!*\
  !*** ./src/marker.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _overlappingMarkerSpiderfier = _interopRequireDefault(__webpack_require__(/*! overlapping-marker-spiderfier */ \"./node_modules/overlapping-marker-spiderfier/lib/oms.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Marker = {\n  valid: function valid(marker) {\n    return marker.position && typeof marker.position.lat === 'number' && typeof marker.position.lng === 'number';\n  },\n  create: function create(marker) {\n    return new google.maps.Marker(marker);\n  },\n  infoWindow: function infoWindow(opts) {\n    return new google.maps.InfoWindow(opts);\n  },\n  createSpiderify: function createSpiderify(_ref) {\n    var map = _ref.map,\n        spiderifyConfig = _ref.spiderifyConfig;\n    return new _overlappingMarkerSpiderfier.default(map, spiderifyConfig);\n  },\n  initializeSpiderify: function initializeSpiderify(oms, googleMarker) {\n    return oms.addMarker(googleMarker);\n  },\n  attachEventHandler: function attachEventHandler(googleMarker, infoWindow, map) {\n    googleMarker.addListener('click', function () {\n      map.activeInfoWindow.close();\n      map.activeInfoWindow = infoWindow; // mutating state, kind of bad\n\n      infoWindow.open(map, googleMarker);\n    });\n  }\n};\nvar _default = Marker;\nexports.default = _default;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/marker.js\n// module id = ./src/marker.js\n// module chunks = main\n\n//# sourceURL=webpack://crowded-google-map/./src/marker.js?");

/***/ })

/******/ });
});