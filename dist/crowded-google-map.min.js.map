{"version":3,"sources":["webpack://crowded-google-map/webpack/universalModuleDefinition","webpack://crowded-google-map/webpack/bootstrap","webpack://crowded-google-map/./node_modules/overlapping-marker-spiderfier/lib/oms.js","webpack://crowded-google-map/./src/marker.js","webpack://crowded-google-map/(webpack)/buildin/global.js","webpack://crowded-google-map/./node_modules/node-js-marker-clusterer/src/markerclusterer.js","webpack://crowded-google-map/./src/Markers.js","webpack://crowded-google-map/./src/config/marker-clusterer.js","webpack://crowded-google-map/./src/config/overlapping-marker-spiderifier.js","webpack://crowded-google-map/./src/config/google-maps.js","webpack://crowded-google-map/./node_modules/object-assign-deep/objectAssignDeep.js","webpack://crowded-google-map/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","t","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","e","hasProp","slice","this","OverlappingMarkerSpiderfier","ge","gm","lcH","lcU","mt","twoPi","_Class","google","maps","event","MapTypeId","Math","PI","keepSpiderfied","markersWontHide","markersWontMove","spiderfiedShadowColor","nudgeStackedMarkers","minNudgeZoomLevel","nudgeRadius","markerCountInBaseNudgeLevel","maxNudgeCount","nudgeBucketSize","nearbyDistance","circleSpiralSwitchover","circleFootSeparation","circleStartAngle","spiralFootSeparation","spiralLengthStart","spiralLengthFactor","spiderfiedZIndex","usualLegZIndex","highlightedLegZIndex","minZoomLevel","lineToCenter","legWeight","legColors","usual","highlighted","HYBRID","SATELLITE","TERRAIN","ROADMAP","map1","opts","j","k","len","ref","v","map","projHelper","constructor","ProjHelper","initMarkerArrays","listeners","length","addListener","_this","unspiderfy","addListenerOnce","mapZoomChangeListener","markers","markerListenerRefs","addMarker","marker","listenerRefs","_oms","spiderListener","push","markerChangeListener","isNudgingActive","requestNudge","nudgeTimeout","clearTimeout","setTimeout","nudgeAllMarkers","getZoom","spiderfied","positionChanged","_omsData","leg","getVisible","spiderfying","unspiderfying","countsPerLevel","levelsByCount","getCountPerNudgeLevel","level","pow","getNudgeLevel","markerIndex","bucketSize","changeX","changeY","changesX","changesY","count","getHash","needsNudge","originalPos","pos","posHash","positions","ref1","ref2","ref3","ref4","ref5","results","ringLevel","floor","x","y","llToPt","usualPosition","position","sin","cos","nudged","setPosition","ptToLl","resetNudgedMarkers","getMarkers","removeMarker","listenerRef","arrIndexOf","splice","removeListener","clearMarkers","len1","func","base","clearListeners","trigger","args","arguments","apply","generatePtsCircle","centerPt","angle","angleStep","legLength","Point","generatePtsSpiral","pt","mPt","markerPt","markerSpiderfied","nDist","nearbyMarkerData","nonNearbyMarkers","pxSq","timeout","getStreetView","getMapTypeId","ptDistanceSq","spiderfy","markersNearMarker","firstOnly","getProjection","markersNearAnyOtherMarker","i1","i2","len2","m1","m1Data","m2","m2Data","mData","willSpiderfy","makeHighlightListenerFuncs","highlight","icon","setOptions","strokeColor","mapTypeId","zIndex","shadow","getIcon","fillOpacity","unhighlight","markerData","bodyPt","centerLl","footLl","footPt","footPts","highlightListenerFuncs","lineOrigin","md","nearestMarkerDatum","numFeet","spiderfiedMarkers","ptAverage","reverse","minExtract","Polyline","path","strokeWeight","Marker","clickable","SymbolPath","CIRCLE","fillColor","scale","hightlightListeners","setZIndex","round","markerNotToMove","unspiderfiedMarkers","setMap","pt1","pt2","dx","dy","pts","numPts","sumX","sumY","ll","fromLatLngToDivPixel","fromDivPixelToLatLng","set","bestIndex","bestVal","index","val","arr","obj","indexOf","OverlayView","draw","_overlappingMarkerSpiderfier","valid","lat","lng","create","infoWindow","InfoWindow","createSpiderify","_ref","spiderifyConfig","initializeSpiderify","oms","googleMarker","attachEventHandler","activeInfoWindow","close","open","g","Function","eval","global","MarkerClusterer","opt_markers","opt_options","extend","map_","markers_","clusters_","sizes","styles_","ready_","options","gridSize_","gridSize","minClusterSize_","minimumClusterSize","maxZoom_","maxZoom","styles","imagePath_","imagePath","MARKER_CLUSTER_IMAGE_PATH_","imageExtension_","imageExtension","MARKER_CLUSTER_IMAGE_EXTENSION_","zoomOnClick_","zoomOnClick","averageCenter_","averageCenter","setupStyles_","prevZoom_","that","zoom","resetViewport","redraw","addMarkers","obj1","obj2","onAdd","setReady_","size","url","height","width","fitMapToMarkers","bounds","LatLngBounds","getPosition","fitBounds","setStyles","getStyles","isZoomOnClick","isAverageCenter","getTotalMarkers","setMaxZoom","getMaxZoom","calculator_","numStyles","dv","parseInt","text","min","setCalculator","calculator","getCalculator","opt_nodraw","pushMarkerTo_","isAdded","draggable","repaint","removeMarker_","removed","removeMarkers","ready","createClusters_","getTotalClusters","getMap","getGridSize","setGridSize","getMinClusterSize","setMinClusterSize","getExtendedBounds","projection","tr","LatLng","getNorthEast","bl","getSouthWest","trPix","blPix","ne","sw","isMarkerInBounds_","contains","opt_hide","cluster","remove","oldClusters","distanceBetweenPoints_","p1","p2","dLat","dLon","a","atan2","sqrt","addToClosestCluster_","distance","clusterToAddTo","center","getCenter","isMarkerInClusterBounds","Cluster","mapBounds","getBounds","markerClusterer","markerClusterer_","center_","bounds_","clusterIcon_","ClusterIcon","isMarkerAlreadyAdded","calculateBounds_","updateIcon","getMarkerClusterer","getSize","mz","hide","sums","setCenter","setSums","show","opt_padding","padding_","cluster_","div_","sums_","visible_","triggerClusterClick","document","createElement","getPosFromLatLng_","style","cssText","createCss","innerHTML","getPanes","overlayMouseTarget","appendChild","addDomListener","latlng","width_","height_","top","left","display","onRemove","parentNode","removeChild","text_","index_","useStyle","max","url_","textColor_","textColor","anchor_","anchor","textSize_","textSize","backgroundPosition_","backgroundPosition","txtColor","txtSize","join","_nodeJsMarkerClusterer","_interopRequireDefault","_marker","assign","writable","key","u","Markers","TypeError","markersData","Error","then","parse","_extends","parseMarkerData","filter","reduce","prev","infoWindowConfig","concat","clustererConfig","basicFormatEvents","getTypeOf","input","Array","isArray","cloneValue","quickCloneObject","quickCloneArray","output","executeDeepMerge","target","_objects","_options","arrayBehaviour","objects","oindex","keys","kindex","type","existingValueType","existingValue","newValue","noMutate","withOptions","_objectAssignDeep","_googleMaps","_overlappingMarkerSpiderifier","_markerClusterer","_Markers","h","DEFAULTS","googleMapsConfig","CrowdedGoogleMap","config","initialize","container","Map"],"mappings":"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","file":"crowded-google-map.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"crowded-google-map\"] = factory();\n\telse\n\t\troot[\"crowded-google-map\"] = factory();\n})(window, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap","// Generated by CoffeeScript 1.10.0\n\n/** @preserve OverlappingMarkerSpiderfier\nhttps://github.com/jawj/OverlappingMarkerSpiderfier\nCopyright (c) 2011 - 2013 George MacKerron\nReleased under the MIT licence: http://opensource.org/licenses/mit-license\nNote: The Google Maps API v3 must be included *before* this code\n */\nvar hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\nthis['OverlappingMarkerSpiderfier'] = (function() {\n  var ge, gm, lcH, lcU, mt, p, twoPi;\n\n  p = _Class.prototype;\n\n  gm = google.maps;\n\n  ge = gm.event;\n\n  mt = gm.MapTypeId;\n\n  twoPi = Math.PI * 2;\n\n  p['keepSpiderfied'] = false;\n\n  p['markersWontHide'] = false;\n\n  p['markersWontMove'] = false;\n\n  p['spiderfiedShadowColor'] = 'white';\n\n  p['nudgeStackedMarkers'] = true;\n\n  p['minNudgeZoomLevel'] = 8;\n\n  p['nudgeRadius'] = 1;\n\n  p['markerCountInBaseNudgeLevel'] = 9;\n\n  p['maxNudgeCount'] = 9;\n\n  p['nudgeBucketSize'] = 12;\n\n  p['nearbyDistance'] = 20;\n\n  p['circleSpiralSwitchover'] = 9;\n\n  p['circleFootSeparation'] = 23;\n\n  p['circleStartAngle'] = twoPi / 12;\n\n  p['spiralFootSeparation'] = 26;\n\n  p['spiralLengthStart'] = 11;\n\n  p['spiralLengthFactor'] = 4;\n\n  p['spiderfiedZIndex'] = 1000;\n\n  p['usualLegZIndex'] = 10;\n\n  p['highlightedLegZIndex'] = 20;\n\n  p['event'] = 'click';\n\n  p['minZoomLevel'] = false;\n\n  p['lineToCenter'] = true;\n\n  p['legWeight'] = 1.5;\n\n  p['legColors'] = {\n    'usual': {},\n    'highlighted': {}\n  };\n\n  lcU = p['legColors']['usual'];\n\n  lcH = p['legColors']['highlighted'];\n\n  lcU[mt.HYBRID] = lcU[mt.SATELLITE] = '#fff';\n\n  lcH[mt.HYBRID] = lcH[mt.SATELLITE] = '#f00';\n\n  lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = '#444';\n\n  lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = '#f00';\n\n  function _Class(map1, opts) {\n    var e, j, k, len, ref, v;\n    this.map = map1;\n    if (opts == null) {\n      opts = {};\n    }\n    for (k in opts) {\n      if (!hasProp.call(opts, k)) continue;\n      v = opts[k];\n      this[k] = v;\n    }\n    this.projHelper = new this.constructor.ProjHelper(this.map);\n    this.initMarkerArrays();\n    this.listeners = {};\n    ref = ['click', 'zoom_changed', 'maptypeid_changed'];\n    for (j = 0, len = ref.length; j < len; j++) {\n      e = ref[j];\n      ge.addListener(this.map, e, (function(_this) {\n        return function() {\n          return _this['unspiderfy']();\n        };\n      })(this));\n    }\n    if (this['nudgeStackedMarkers']) {\n      ge.addListenerOnce(this.map, 'idle', (function(_this) {\n        return function() {\n          ge.addListener(_this.map, 'zoom_changed', function() {\n            return _this.mapZoomChangeListener();\n          });\n          return _this.mapZoomChangeListener();\n        };\n      })(this));\n    }\n  }\n\n  p.initMarkerArrays = function() {\n    this.markers = [];\n    return this.markerListenerRefs = [];\n  };\n\n  p['addMarker'] = function(marker) {\n    var listenerRefs;\n    if (marker['_oms'] != null) {\n      return this;\n    }\n    marker['_oms'] = true;\n    listenerRefs = [\n      ge.addListener(marker, this['event'], (function(_this) {\n        return function(event) {\n          return _this.spiderListener(marker, event);\n        };\n      })(this))\n    ];\n    if (!this['markersWontHide']) {\n      listenerRefs.push(ge.addListener(marker, 'visible_changed', (function(_this) {\n        return function() {\n          return _this.markerChangeListener(marker, false);\n        };\n      })(this)));\n    }\n    if (!this['markersWontMove']) {\n      listenerRefs.push(ge.addListener(marker, 'position_changed', (function(_this) {\n        return function() {\n          return _this.markerChangeListener(marker, true);\n        };\n      })(this)));\n    }\n    this.markerListenerRefs.push(listenerRefs);\n    this.markers.push(marker);\n    if (this.isNudgingActive()) {\n      this.requestNudge();\n    }\n    return this;\n  };\n\n  p.nudgeTimeout = null;\n\n  p.requestNudge = function() {\n    if (this.nudgeTimeout) {\n      clearTimeout(this.nudgeTimeout);\n    }\n    return this.nudgeTimeout = setTimeout((function(_this) {\n      return function() {\n        return _this.nudgeAllMarkers();\n      };\n    })(this), 10);\n  };\n\n  p.isNudgingActive = function() {\n    return this['nudgeStackedMarkers'] && !(this['minNudgeZoomLevel'] && this.map.getZoom() < this['minNudgeZoomLevel']) && !this.spiderfied;\n  };\n\n  p.markerChangeListener = function(marker, positionChanged) {\n    if ((marker['_omsData'] != null) && marker['_omsData'].leg && (positionChanged || !marker.getVisible()) && !((this.spiderfying != null) || (this.unspiderfying != null))) {\n      return this['unspiderfy'](positionChanged ? marker : null);\n    }\n  };\n\n  p.countsPerLevel = [1, 1];\n\n  p.levelsByCount = [];\n\n  p.getCountPerNudgeLevel = function(level) {\n    if (this.countsPerLevel[level] != null) {\n      return this.countsPerLevel[level];\n    }\n    this.countsPerLevel[level] = this.getCountPerNudgeLevel(level - 1) + Math.pow(2, level - 2) * this['markerCountInBaseNudgeLevel'];\n    return this.countsPerLevel[level];\n  };\n\n  p.getNudgeLevel = function(markerIndex) {\n    var level;\n    if (this.levelsByCount[markerIndex] != null) {\n      return this.levelsByCount[markerIndex];\n    }\n    level = 0;\n    while (markerIndex >= this.countsPerLevel[level]) {\n      if (level + 1 >= this.countsPerLevel.length) {\n        this.getCountPerNudgeLevel(level + 1);\n      }\n      level++;\n    }\n    this.levelsByCount[markerIndex] = level - 1;\n    return this.levelsByCount[markerIndex];\n  };\n\n  p.nudgeAllMarkers = function() {\n    var bucketSize, changeX, changeY, changesX, changesY, count, getHash, j, len, m, needsNudge, originalPos, pos, posHash, positions, ref, ref1, ref2, ref3, ref4, ref5, results, ringLevel;\n    if (!this.isNudgingActive()) {\n      return;\n    }\n    positions = {};\n    changesX = [];\n    changesY = [];\n    bucketSize = 1 / ((1 + this['nudgeBucketSize']) * this['nudgeRadius']);\n    getHash = (function(_this) {\n      return function(pos) {\n        return Math.floor(pos.x * bucketSize) + ',' + Math.floor(pos.y * bucketSize);\n      };\n    })(this);\n    ref = this.markers;\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n      m = ref[j];\n      needsNudge = false;\n      pos = this.llToPt((ref1 = (ref2 = m['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : m.position);\n      originalPos = {\n        x: pos.x,\n        y: pos.y\n      };\n      posHash = getHash(pos);\n      while ((positions[posHash] != null) && ((this['maxNudgeCount'] == null) || positions[posHash] <= this['maxNudgeCount'])) {\n        count = positions[posHash];\n        positions[posHash] += 1;\n        if (changesX[count] != null) {\n          changeX = changesX[count];\n          changeY = changesY[count];\n        } else {\n          ringLevel = this.getNudgeLevel(count);\n          changesX[count] = changeX = Math.sin(twoPi * count / this['markerCountInBaseNudgeLevel'] / ringLevel) * 20 * this['nudgeRadius'] * ringLevel;\n          changesY[count] = changeY = Math.cos(twoPi * count / this['markerCountInBaseNudgeLevel'] / ringLevel) * 20 * this['nudgeRadius'] * ringLevel;\n        }\n        pos.x = originalPos.x + changeX;\n        pos.y = originalPos.y + changeY;\n        this.nudged = true;\n        needsNudge = true;\n        posHash = getHash(pos);\n      }\n      if (needsNudge) {\n        m['_omsData'] = (ref3 = m['_omsData']) != null ? ref3 : {};\n        m['_omsData'].usualPosition = (ref4 = (ref5 = m['_omsData']) != null ? ref5.usualPosition : void 0) != null ? ref4 : m.position;\n        m.setPosition(this.ptToLl(pos));\n      } else if ((m['_omsData'] != null) && (m['_omsData'].leg == null)) {\n        m.setPosition(m['_omsData'].usualPosition);\n        delete m['_omsData'];\n      }\n      if (!(posHash in positions)) {\n        results.push(positions[posHash] = 1);\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  p.resetNudgedMarkers = function() {\n    var j, len, m, ref;\n    if (!this.nudged) {\n      return;\n    }\n    ref = this.markers;\n    for (j = 0, len = ref.length; j < len; j++) {\n      m = ref[j];\n      if ((m['_omsData'] != null) && (m['_omsData'].leg == null)) {\n        m.setPosition(m['_omsData'].usualPosition);\n        delete m['_omsData'];\n      }\n    }\n    return delete this.nudged;\n  };\n\n  p.mapZoomChangeListener = function() {\n    if (this['minNudgeZoomLevel'] && this.map.getZoom() < this['minNudgeZoomLevel']) {\n      return this.resetNudgedMarkers();\n    }\n    return this.requestNudge();\n  };\n\n  p['getMarkers'] = function() {\n    return this.markers.slice(0);\n  };\n\n  p['removeMarker'] = function(marker) {\n    var i, j, len, listenerRef, listenerRefs;\n    if (marker['_omsData'] != null) {\n      this['unspiderfy']();\n    }\n    i = this.arrIndexOf(this.markers, marker);\n    if (i < 0) {\n      return this;\n    }\n    listenerRefs = this.markerListenerRefs.splice(i, 1)[0];\n    for (j = 0, len = listenerRefs.length; j < len; j++) {\n      listenerRef = listenerRefs[j];\n      ge.removeListener(listenerRef);\n    }\n    delete marker['_oms'];\n    this.markers.splice(i, 1);\n    if (this.isNudgingActive()) {\n      this.requestNudge();\n    }\n    return this;\n  };\n\n  p['clearMarkers'] = function() {\n    var i, j, l, len, len1, listenerRef, listenerRefs, marker, ref;\n    this['unspiderfy']();\n    ref = this.markers;\n    for (i = j = 0, len = ref.length; j < len; i = ++j) {\n      marker = ref[i];\n      listenerRefs = this.markerListenerRefs[i];\n      for (l = 0, len1 = listenerRefs.length; l < len1; l++) {\n        listenerRef = listenerRefs[l];\n        ge.removeListener(listenerRef);\n      }\n      delete marker['_oms'];\n    }\n    this.initMarkerArrays();\n    return this;\n  };\n\n  p['addListener'] = function(event, func) {\n    var base;\n    ((base = this.listeners)[event] != null ? base[event] : base[event] = []).push(func);\n    return this;\n  };\n\n  p['removeListener'] = function(event, func) {\n    var i;\n    i = this.arrIndexOf(this.listeners[event], func);\n    if (!(i < 0)) {\n      this.listeners[event].splice(i, 1);\n    }\n    return this;\n  };\n\n  p['clearListeners'] = function(event) {\n    this.listeners[event] = [];\n    return this;\n  };\n\n  p.trigger = function() {\n    var args, event, func, j, len, ref, ref1, results;\n    event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    ref1 = (ref = this.listeners[event]) != null ? ref : [];\n    results = [];\n    for (j = 0, len = ref1.length; j < len; j++) {\n      func = ref1[j];\n      results.push(func.apply(null, args));\n    }\n    return results;\n  };\n\n  p.generatePtsCircle = function(count, centerPt) {\n    var angle, angleStep, circumference, i, j, legLength, ref, results;\n    circumference = this['circleFootSeparation'] * (2 + count);\n    legLength = circumference / twoPi;\n    angleStep = twoPi / count;\n    results = [];\n    for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      angle = this['circleStartAngle'] + i * angleStep;\n      results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));\n    }\n    return results;\n  };\n\n  p.generatePtsSpiral = function(count, centerPt) {\n    var angle, i, j, legLength, pt, ref, results;\n    legLength = this['spiralLengthStart'];\n    angle = 0;\n    results = [];\n    for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      angle += this['spiralFootSeparation'] / legLength + i * 0.0005;\n      pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));\n      legLength += twoPi * this['spiralLengthFactor'] / angle;\n      results.push(pt);\n    }\n    return results;\n  };\n\n  p.spiderListener = function(marker, event) {\n    var j, len, m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, ref;\n    markerSpiderfied = (marker['_omsData'] != null) && (marker['_omsData'].leg != null);\n    if (!(markerSpiderfied && this['keepSpiderfied'])) {\n      if (this['event'] === 'mouseover') {\n        window.clearTimeout(p.timeout);\n        p.timeout = setTimeout((function(_this) {\n          return function() {\n            return _this['unspiderfy']();\n          };\n        })(this), 3000);\n      } else {\n        this['unspiderfy']();\n      }\n    }\n    if (markerSpiderfied || this.map.getStreetView().getVisible() || this.map.getMapTypeId() === 'GoogleEarthAPI' || this['minZoomLevel'] && this.map.getZoom() < this['minZoomLevel']) {\n      return this.trigger('click', marker, event);\n    } else {\n      nearbyMarkerData = [];\n      nonNearbyMarkers = [];\n      nDist = this['nearbyDistance'];\n      pxSq = nDist * nDist;\n      markerPt = this.llToPt(marker.position);\n      ref = this.markers;\n      for (j = 0, len = ref.length; j < len; j++) {\n        m = ref[j];\n        if (!((m.map != null) && m.getVisible())) {\n          continue;\n        }\n        mPt = this.llToPt(m.position);\n        if (this.ptDistanceSq(mPt, markerPt) < pxSq) {\n          nearbyMarkerData.push({\n            marker: m,\n            markerPt: mPt\n          });\n        } else {\n          nonNearbyMarkers.push(m);\n        }\n      }\n      if (nearbyMarkerData.length === 1) {\n        return this.trigger('click', marker, event);\n      } else {\n        return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);\n      }\n    }\n  };\n\n  p['markersNearMarker'] = function(marker, firstOnly) {\n    var j, len, m, mPt, markerPt, markers, nDist, pxSq, ref, ref1, ref2;\n    if (firstOnly == null) {\n      firstOnly = false;\n    }\n    if (this.projHelper.getProjection() == null) {\n      throw \"Must wait for 'idle' event on map before calling markersNearMarker\";\n    }\n    nDist = this['nearbyDistance'];\n    pxSq = nDist * nDist;\n    markerPt = this.llToPt(marker.position);\n    markers = [];\n    ref = this.markers;\n    for (j = 0, len = ref.length; j < len; j++) {\n      m = ref[j];\n      if (m === marker || (m.map == null) || !m.getVisible()) {\n        continue;\n      }\n      mPt = this.llToPt((ref1 = (ref2 = m['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : m.position);\n      if (this.ptDistanceSq(mPt, markerPt) < pxSq) {\n        markers.push(m);\n        if (firstOnly) {\n          break;\n        }\n      }\n    }\n    return markers;\n  };\n\n  p['markersNearAnyOtherMarker'] = function() {\n    var i, i1, i2, j, l, len, len1, len2, m, m1, m1Data, m2, m2Data, mData, n, nDist, pxSq, ref, ref1, ref2, results;\n    if (this.projHelper.getProjection() == null) {\n      throw \"Must wait for 'idle' event on map before calling markersNearAnyOtherMarker\";\n    }\n    nDist = this['nearbyDistance'];\n    pxSq = nDist * nDist;\n    mData = (function() {\n      var j, len, ref, ref1, ref2, results;\n      ref = this.markers;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        m = ref[j];\n        results.push({\n          pt: this.llToPt((ref1 = (ref2 = m['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : m.position),\n          willSpiderfy: false\n        });\n      }\n      return results;\n    }).call(this);\n    ref = this.markers;\n    for (i1 = j = 0, len = ref.length; j < len; i1 = ++j) {\n      m1 = ref[i1];\n      if (!((m1.map != null) && m1.getVisible())) {\n        continue;\n      }\n      m1Data = mData[i1];\n      if (m1Data.willSpiderfy) {\n        continue;\n      }\n      ref1 = this.markers;\n      for (i2 = l = 0, len1 = ref1.length; l < len1; i2 = ++l) {\n        m2 = ref1[i2];\n        if (i2 === i1) {\n          continue;\n        }\n        if (!((m2.map != null) && m2.getVisible())) {\n          continue;\n        }\n        m2Data = mData[i2];\n        if (i2 < i1 && !m2Data.willSpiderfy) {\n          continue;\n        }\n        if (this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {\n          m1Data.willSpiderfy = m2Data.willSpiderfy = true;\n          break;\n        }\n      }\n    }\n    ref2 = this.markers;\n    results = [];\n    for (i = n = 0, len2 = ref2.length; n < len2; i = ++n) {\n      m = ref2[i];\n      if (mData[i].willSpiderfy) {\n        results.push(m);\n      }\n    }\n    return results;\n  };\n\n  p.makeHighlightListenerFuncs = function(marker) {\n    return {\n      highlight: (function(_this) {\n        return function() {\n          var icon;\n          marker['_omsData'].leg.setOptions({\n            strokeColor: _this['legColors']['highlighted'][_this.map.mapTypeId],\n            zIndex: _this['highlightedLegZIndex']\n          });\n          if (marker['_omsData'].shadow != null) {\n            icon = marker['_omsData'].shadow.getIcon();\n            icon.fillOpacity = 0.8;\n            return marker['_omsData'].shadow.setOptions({\n              icon: icon\n            });\n          }\n        };\n      })(this),\n      unhighlight: (function(_this) {\n        return function() {\n          var icon;\n          marker['_omsData'].leg.setOptions({\n            strokeColor: _this['legColors']['usual'][_this.map.mapTypeId],\n            zIndex: _this['usualLegZIndex']\n          });\n          if (marker['_omsData'].shadow != null) {\n            icon = marker['_omsData'].shadow.getIcon();\n            icon.fillOpacity = 0.3;\n            return marker['_omsData'].shadow.setOptions({\n              icon: icon\n            });\n          }\n        };\n      })(this)\n    };\n  };\n\n  p.spiderfy = function(markerData, nonNearbyMarkers) {\n    var bodyPt, centerLl, footLl, footPt, footPts, highlightListenerFuncs, leg, lineOrigin, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;\n    this.spiderfying = true;\n    numFeet = markerData.length;\n    bodyPt = this.ptAverage((function() {\n      var j, len, results;\n      results = [];\n      for (j = 0, len = markerData.length; j < len; j++) {\n        md = markerData[j];\n        results.push(md.markerPt);\n      }\n      return results;\n    })());\n    footPts = numFeet >= this['circleSpiralSwitchover'] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);\n    centerLl = this.ptToLl(bodyPt);\n    spiderfiedMarkers = (function() {\n      var j, len, ref, ref1, ref2, results;\n      results = [];\n      for (j = 0, len = footPts.length; j < len; j++) {\n        footPt = footPts[j];\n        footLl = this.ptToLl(footPt);\n        nearestMarkerDatum = this.minExtract(markerData, (function(_this) {\n          return function(md) {\n            return _this.ptDistanceSq(md.markerPt, footPt);\n          };\n        })(this));\n        marker = nearestMarkerDatum.marker;\n        lineOrigin = this['lineToCenter'] ? centerLl : marker.position;\n        leg = new gm.Polyline({\n          map: this.map,\n          path: [lineOrigin, footLl],\n          strokeColor: this['legColors']['usual'][this.map.mapTypeId],\n          strokeWeight: this['legWeight'],\n          zIndex: this['usualLegZIndex']\n        });\n        marker['_omsData'] = (ref = marker['_omsData']) != null ? ref : {};\n        marker['_omsData'].usualPosition = (ref1 = (ref2 = marker['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : marker.position;\n        marker['_omsData'].leg = leg;\n        if (this['spiderfiedShadowColor']) {\n          marker['_omsData'].shadow = new gm.Marker({\n            position: footLl,\n            map: this.map,\n            clickable: false,\n            zIndex: -2,\n            icon: {\n              path: google.maps.SymbolPath.CIRCLE,\n              fillOpacity: 0.3,\n              fillColor: this['spiderfiedShadowColor'],\n              strokeWeight: 0,\n              scale: 20\n            }\n          });\n        }\n        if (this['legColors']['highlighted'][this.map.mapTypeId] !== this['legColors']['usual'][this.map.mapTypeId]) {\n          highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);\n          marker['_omsData'].hightlightListeners = {\n            highlight: ge.addListener(marker, 'mouseover', highlightListenerFuncs.highlight),\n            unhighlight: ge.addListener(marker, 'mouseout', highlightListenerFuncs.unhighlight)\n          };\n        }\n        marker.setPosition(footLl);\n        marker.setZIndex(Math.round(this['spiderfiedZIndex'] + footPt.y));\n        results.push(marker);\n      }\n      return results;\n    }).call(this);\n    delete this.spiderfying;\n    this.spiderfied = true;\n    return this.trigger('spiderfy', spiderfiedMarkers, nonNearbyMarkers);\n  };\n\n  p['unspiderfy'] = function(markerNotToMove) {\n    var j, len, listeners, marker, nonNearbyMarkers, ref, ref1, unspiderfiedMarkers;\n    if (markerNotToMove == null) {\n      markerNotToMove = null;\n    }\n    if (!((this.spiderfied != null) || (this.nudged != null))) {\n      return this;\n    }\n    this.unspiderfying = true;\n    unspiderfiedMarkers = [];\n    nonNearbyMarkers = [];\n    ref = this.markers;\n    for (j = 0, len = ref.length; j < len; j++) {\n      marker = ref[j];\n      if ((marker['_omsData'] != null) && (marker['_omsData'].leg != null)) {\n        marker['_omsData'].leg.setMap(null);\n        if ((ref1 = marker['_omsData'].shadow) != null) {\n          ref1.setMap(null);\n        }\n        if (marker !== markerNotToMove) {\n          marker.setPosition(marker['_omsData'].usualPosition);\n        }\n        marker.setZIndex(null);\n        listeners = marker['_omsData'].hightlightListeners;\n        if (listeners != null) {\n          ge.removeListener(listeners.highlight);\n          ge.removeListener(listeners.unhighlight);\n        }\n        delete marker['_omsData'];\n        unspiderfiedMarkers.push(marker);\n      } else {\n        nonNearbyMarkers.push(marker);\n      }\n    }\n    delete this.unspiderfying;\n    delete this.spiderfied;\n    this.trigger('unspiderfy', unspiderfiedMarkers, nonNearbyMarkers);\n    if (this.nudged) {\n      this.requestNudge();\n    }\n    return this;\n  };\n\n  p.ptDistanceSq = function(pt1, pt2) {\n    var dx, dy;\n    dx = pt1.x - pt2.x;\n    dy = pt1.y - pt2.y;\n    return dx * dx + dy * dy;\n  };\n\n  p.ptAverage = function(pts) {\n    var j, len, numPts, pt, sumX, sumY;\n    sumX = sumY = 0;\n    for (j = 0, len = pts.length; j < len; j++) {\n      pt = pts[j];\n      sumX += pt.x;\n      sumY += pt.y;\n    }\n    numPts = pts.length;\n    return new gm.Point(sumX / numPts, sumY / numPts);\n  };\n\n  p.llToPt = function(ll) {\n    return this.projHelper.getProjection().fromLatLngToDivPixel(ll);\n  };\n\n  p.ptToLl = function(pt) {\n    return this.projHelper.getProjection().fromDivPixelToLatLng(pt);\n  };\n\n  p.minExtract = function(set, func) {\n    var bestIndex, bestVal, index, item, j, len, val;\n    for (index = j = 0, len = set.length; j < len; index = ++j) {\n      item = set[index];\n      val = func(item);\n      if ((typeof bestIndex === \"undefined\" || bestIndex === null) || val < bestVal) {\n        bestVal = val;\n        bestIndex = index;\n      }\n    }\n    return set.splice(bestIndex, 1)[0];\n  };\n\n  p.arrIndexOf = function(arr, obj) {\n    var i, j, len, o;\n    if (arr.indexOf != null) {\n      return arr.indexOf(obj);\n    }\n    for (i = j = 0, len = arr.length; j < len; i = ++j) {\n      o = arr[i];\n      if (o === obj) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  _Class.ProjHelper = function(map) {\n    return this.setMap(map);\n  };\n\n  _Class.ProjHelper.prototype = new gm.OverlayView();\n\n  _Class.ProjHelper.prototype['draw'] = function() {};\n\n  return _Class;\n\n})();\n\nmodule.exports = this['OverlappingMarkerSpiderfier'];\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/overlapping-marker-spiderfier/lib/oms.js\n// module id = 0\n// module chunks = 0","import OverlappingMarkerSpiderfier from 'overlapping-marker-spiderfier';\n\nconst Marker = {\n  valid: marker =>\n    marker.position && typeof marker.position.lat === 'number' && typeof marker.position.lng === 'number',\n  create: marker => new google.maps.Marker(marker),\n  infoWindow: opts => new google.maps.InfoWindow(opts),\n  createSpiderify: ({ map, spiderifyConfig }) => new OverlappingMarkerSpiderfier(map, spiderifyConfig),\n  initializeSpiderify: (oms, googleMarker) => oms.addMarker(googleMarker),\n  attachEventHandler: (googleMarker, infoWindow, map) => {\n    googleMarker.addListener('click', () => {\n      map.activeInfoWindow.close();\n      map.activeInfoWindow = infoWindow; // mutating state, kind of bad\n      infoWindow.open(map, googleMarker);\n    });\n  }\n};\n\nexport default Marker;\n\n\n\n// WEBPACK FOOTER //\n// ./src/marker.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 2\n// module chunks = 0","/**\n * Npm version of markerClusterer works great with browserify and google maps for commonjs\n * https://www.npmjs.com/package/googlemaps\n * Difference from the original - adds a commonjs format and replaces window with global and some unit test\n * The original functionality it's not modified for docs and original source check\n * https://github.com/googlemaps/js-marker-clusterer\n */\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n * <br/>\n * This is a v3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >v2 MarkerClusterer</a>.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'averageCenter': (boolean) Wether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] ||\n      this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] ||\n      this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    var zoom = that.map_.getZoom();\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && opt_markers.length) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =\n    'http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/' +\n    'images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return (function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    this.pushMarkerTo_(marker);\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n   return false;\n  }\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  var removed = false;\n\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n      this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n      markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {number} The cluster center.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {Array.<google.maps.Marker>} The cluster center.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function() {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function() {\n    that.triggerClusterClick();\n  });\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n  }\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n        this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) +\n          'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n          'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n        this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) +\n          'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' +\n        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nglobal['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n    MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n    MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n    MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n    MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n    MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n    MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n    MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n    MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n    MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n    MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n    MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n    MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n    MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n    MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\n\nmodule.exports = MarkerClusterer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/node-js-marker-clusterer/src/markerclusterer.js\n// module id = 3\n// module chunks = 0","import MarkerClusterer from 'node-js-marker-clusterer';\nimport Marker from './marker';\n\nclass Markers {\n  constructor(opts) {\n    if (!opts || !opts.markersData || !opts.map) {\n      throw new Error('CrowdedGoogleMap :: Some required options are missing');\n      return;\n    }\n\n    this.get(opts)\n      .then(this.parse)\n      // .then(this.waitForMap)\n      .then(this.create)\n      .then(this.cluster);\n  }\n\n  get(opts) {\n    return opts.markersData.then(markers => {\n      return Object.assign({}, opts, {\n        markersData: markers\n      });\n    });\n  }\n\n  parse(opts) {\n    return Object.assign({}, opts, {\n      markersData: opts.markersData.map(opts.parseMarkerData)\n    });\n  }\n\n  // waitForMap(opts) {\n  // const isInitialized = opts => typeof opts.map.getProjection() === 'object';\n\n  // return new Promise(resolve => {\n  // const resolveIfReady = () => {\n  //   if (isInitialized(opts)) {\n  //     resolve(opts);\n  //   } else {\n  //     requestAnimationFrame(resolveIfReady);\n  //   }\n  // };\n\n  // requestAnimationFrame(resolveIfReady);\n  // });\n  // }\n\n  create(opts) {\n    const oms = Marker.createSpiderify(opts);\n\n    return Object.assign({}, opts, {\n      markersData: opts.markersData.filter(Marker.valid).reduce((prev, marker) => {\n        const googleMarker = Marker.create(marker);\n        const infoWindowConfig = opts.infoWindowConfig(marker);\n        const infoWindow = Marker.infoWindow(infoWindowConfig);\n\n        Marker.attachEventHandler(googleMarker, infoWindow, opts.map);\n        Marker.initializeSpiderify(oms, googleMarker);\n\n        return [...prev, googleMarker];\n      }, [])\n    });\n  }\n\n  cluster({ map, markersData, clustererConfig }) {\n    return new MarkerClusterer(map, markersData, clustererConfig);\n  }\n}\n\nexport default Markers;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Markers.js","export default {\n  gridSize: 50,\n  maxZoom: 14\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/config/marker-clusterer.js","export default {\n  markersWontMove: true,\n  markersWontHide: true,\n  circleFootSeparation: 60,\n  nearbyDistance: 60,\n  keepSpiderfied: true,\n  basicFormatEvents: true\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/config/overlapping-marker-spiderifier.js","export default {\n  center: { lat: -25.363, lng: 131.044 },\n  zoom: 5\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/config/google-maps.js","'use strict';\n\n/*\n * OBJECT ASSIGN DEEP\n * Allows deep cloning of plain objects that contain primitives, nested plain objects, or nested plain arrays.\n */\n\n/*\n * A unified way of returning a string that describes the type of the given variable.\n */\nfunction getTypeOf (input) {\n\n\tif (input === null) {\n\t\treturn `null`;\n\t}\n\n\telse if (typeof input === `undefined`) {\n\t\treturn `undefined`;\n\t}\n\n\telse if (typeof input === `object`) {\n\t\treturn (Array.isArray(input) ? `array` : `object`);\n\t}\n\n\treturn typeof input;\n\n}\n\n/*\n * Branching logic which calls the correct function to clone the given value base on its type.\n */\nfunction cloneValue (value) {\n\n\t// The value is an object so lets clone it.\n\tif (getTypeOf(value) === `object`) {\n\t\treturn quickCloneObject(value);\n\t}\n\n\t// The value is an array so lets clone it.\n\telse if (getTypeOf(value) === `array`) {\n\t\treturn quickCloneArray(value);\n\t}\n\n\t// Any other value can just be copied.\n\treturn value;\n\n}\n\n/*\n * Enumerates the given array and returns a new array, with each of its values cloned (i.e. references broken).\n */\nfunction quickCloneArray (input) {\n\treturn input.map(cloneValue);\n}\n\n/*\n * Enumerates the properties of the given object (ignoring the prototype chain) and returns a new object, with each of\n * its values cloned (i.e. references broken).\n */\nfunction quickCloneObject (input) {\n\n\tconst output = {};\n\n\tfor (const key in input) {\n\t\tif (!input.hasOwnProperty(key)) { continue; }\n\n\t\toutput[key] = cloneValue(input[key]);\n\t}\n\n\treturn output;\n\n}\n\n/*\n * Does the actual deep merging.\n */\nfunction executeDeepMerge (target, _objects = [], _options = {}) {\n\n\tconst options = {\n\t\tarrayBehaviour: _options.arrayBehaviour || `replace`,  // Can be \"merge\" or \"replace\".\n\t};\n\n\t// Ensure we have actual objects for each.\n\tconst objects = _objects.map(object => object || {});\n\n\tconst output = target || {};\n\n\t// Enumerate the objects and their keys.\n\tfor (let oindex = 0; oindex < objects.length; oindex++) {\n\t\tconst object = objects[oindex];\n\t\tconst keys = Object.keys(object);\n\n\t\tfor (let kindex = 0; kindex < keys.length; kindex++) {\n\t\t\tconst key = keys[kindex];\n\t\t\tconst value = object[key];\n\t\t\tconst type = getTypeOf(value);\n\t\t\tconst existingValueType = getTypeOf(output[key]);\n\n\t\t\tif (type === `object`) {\n\t\t\t\tif (existingValueType !== `undefined`) {\n\t\t\t\t\tconst existingValue = (existingValueType === `object` ? output[key] : {});\n\t\t\t\t\toutput[key] = executeDeepMerge({}, [existingValue, quickCloneObject(value)], options);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[key] = quickCloneObject(value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (type === `array`) {\n\t\t\t\tif (existingValueType === `array`) {\n\t\t\t\t\tconst newValue = quickCloneArray(value);\n\t\t\t\t\toutput[key] = (options.arrayBehaviour === `merge` ? output[key].concat(newValue) : newValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[key] = quickCloneArray(value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\toutput[key] = value;\n\t\t\t}\n\n\n\t\t}\n\t}\n\n\treturn output;\n\n}\n\n/*\n * Merge all the supplied objects into the target object, breaking all references, including those of nested objects\n * and arrays, and even objects nested inside arrays. The first parameter is not mutated unlike Object.assign().\n * Properties in later objects will always overwrite.\n */\nmodule.exports = function objectAssignDeep (target, ...objects) {\n\treturn executeDeepMerge(target, objects);\n};\n\n/*\n * Same as objectAssignDeep() except it doesn't mutate the target object and returns an entirely new object.\n */\nmodule.exports.noMutate = function objectAssignDeepInto (...objects) {\n\treturn executeDeepMerge({}, objects);\n};\n\n/*\n * Allows an options object to be passed in to customise the behaviour of the function.\n */\nmodule.exports.withOptions = function objectAssignDeepInto (target, objects, options) {\n\treturn executeDeepMerge(target, objects, options);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/object-assign-deep/objectAssignDeep.js\n// module id = 8\n// module chunks = 0","import assignDeep from 'object-assign-deep';\n\nimport GoogleMapsDefaults from './config/google-maps';\nimport omsDefaults from './config/overlapping-marker-spiderifier';\nimport MarkerClustererDefaults from './config/marker-clusterer';\n\nimport Markers from './Markers';\n\nconst DEFAULTS = {\n  googleMapsConfig: GoogleMapsDefaults,\n  clustererConfig: MarkerClustererDefaults,\n  spiderifyConfig: omsDefaults,\n  activeInfoWindow: {\n    close: () => {}\n  },\n  markersData: [],\n  infoWindowConfig: m => m,\n  parseMarkerData: m => m\n};\n\nclass CrowdedGoogleMap {\n  constructor(config) {\n    const opts = assignDeep({}, DEFAULTS, config);\n    const options = Object.assign({}, opts, {\n      map: this.initialize(config.container, opts),\n      markersData: config.markersData\n    });\n\n    new Markers(options);\n  }\n\n  initialize(container, { googleMapsConfig, activeInfoWindow }) {\n    return new google.maps.Map(container, {\n      center: googleMapsConfig.center,\n      zoom: googleMapsConfig.zoom,\n      activeInfoWindow: activeInfoWindow\n    });\n  }\n}\n\nwindow.CrowdedGoogleMap = CrowdedGoogleMap;\n\nexport default CrowdedGoogleMap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}