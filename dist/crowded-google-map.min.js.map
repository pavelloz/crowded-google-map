{"version":3,"sources":["webpack://crowded-google-map/webpack/universalModuleDefinition","webpack://crowded-google-map/webpack/bootstrap","webpack://crowded-google-map/./node_modules/object-assign-deep/objectAssignDeep.js","webpack://crowded-google-map/./node_modules/node-js-marker-clusterer/src/markerclusterer.js","webpack://crowded-google-map/./node_modules/overlapping-marker-spiderfier/lib/oms.js","webpack://crowded-google-map/(webpack)/buildin/global.js","webpack://crowded-google-map/./src/marker.js","webpack://crowded-google-map/./src/Markers.js","webpack://crowded-google-map/./src/index.js","webpack://crowded-google-map/./src/config/google-maps.js","webpack://crowded-google-map/./src/config/marker-clusterer.js","webpack://crowded-google-map/./src/config/overlapping-marker-spiderifier.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","getTypeOf","input","Array","isArray","cloneValue","quickCloneObject","quickCloneArray","map","output","executeDeepMerge","target","_objects","_options","options","arrayBehaviour","objects","oindex","length","keys","kindex","type","existingValueType","existingValue","newValue","concat","noMutate","withOptions","global","MarkerClusterer","opt_markers","opt_options","this","extend","google","maps","OverlayView","map_","markers_","clusters_","sizes","styles_","ready_","gridSize_","minClusterSize_","maxZoom_","imagePath_","MARKER_CLUSTER_IMAGE_PATH_","imageExtension_","MARKER_CLUSTER_IMAGE_EXTENSION_","zoomOnClick_","undefined","averageCenter_","setupStyles_","setMap","prevZoom_","getZoom","that","event","addListener","zoom","resetViewport","redraw","addMarkers","Cluster","markerClusterer","markerClusterer_","getMap","getGridSize","getMinClusterSize","isAverageCenter","center_","bounds_","clusterIcon_","ClusterIcon","getStyles","cluster","styles","opt_padding","getMarkerClusterer","padding_","cluster_","div_","sums_","visible_","obj1","obj2","apply","onAdd","setReady_","draw","size","push","url","height","width","fitMapToMarkers","marker","markers","getMarkers","bounds","LatLngBounds","getPosition","fitBounds","setStyles","isZoomOnClick","getTotalMarkers","setMaxZoom","maxZoom","getMaxZoom","calculator_","numStyles","index","count","dv","parseInt","text","Math","min","setCalculator","calculator","getCalculator","opt_nodraw","pushMarkerTo_","isAdded","repaint","addMarker","removeMarker_","indexOf","splice","removeMarker","removed","removeMarkers","ready","createClusters_","getTotalClusters","setGridSize","setMinClusterSize","getExtendedBounds","projection","getProjection","tr","LatLng","getNorthEast","lat","lng","bl","getSouthWest","trPix","fromLatLngToDivPixel","x","y","blPix","ne","fromDivPixelToLatLng","sw","isMarkerInBounds_","contains","clearMarkers","opt_hide","remove","oldClusters","slice","setTimeout","distanceBetweenPoints_","p1","p2","dLat","PI","dLon","a","sin","cos","atan2","sqrt","addToClosestCluster_","distance","clusterToAddTo","center","getCenter","isMarkerInClusterBounds","mapBounds","getBounds","isMarkerAlreadyAdded","calculateBounds_","len","updateIcon","getSize","mz","hide","sums","setCenter","setSums","show","triggerClusterClick","trigger","document","createElement","pos","getPosFromLatLng_","style","cssText","createCss","innerHTML","getPanes","overlayMouseTarget","appendChild","addDomListener","latlng","width_","height_","top","left","display","onRemove","parentNode","removeChild","text_","index_","useStyle","max","url_","textColor_","anchor_","textSize_","backgroundPosition_","backgroundPosition","txtColor","txtSize","join","hasProp","ge","gm","lcH","lcU","mt","twoPi","_Class","map1","opts","e","j","k","ref","v","projHelper","constructor","ProjHelper","initMarkerArrays","listeners","_this","addListenerOnce","mapZoomChangeListener","MapTypeId","usual","highlighted","HYBRID","SATELLITE","TERRAIN","ROADMAP","markerListenerRefs","listenerRefs","spiderListener","markerChangeListener","isNudgingActive","requestNudge","nudgeTimeout","clearTimeout","nudgeAllMarkers","spiderfied","positionChanged","leg","getVisible","spiderfying","unspiderfying","countsPerLevel","levelsByCount","getCountPerNudgeLevel","level","pow","getNudgeLevel","markerIndex","bucketSize","changeX","changeY","changesX","changesY","getHash","needsNudge","originalPos","posHash","positions","ref1","ref2","ref3","ref4","ref5","results","ringLevel","floor","llToPt","usualPosition","position","nudged","setPosition","ptToLl","resetNudgedMarkers","listenerRef","arrIndexOf","removeListener","len1","func","base","args","arguments","generatePtsCircle","centerPt","angle","angleStep","legLength","Point","generatePtsSpiral","pt","mPt","markerPt","markerSpiderfied","nDist","nearbyMarkerData","nonNearbyMarkers","pxSq","timeout","getStreetView","getMapTypeId","ptDistanceSq","spiderfy","firstOnly","i1","i2","len2","m1","m1Data","m2","m2Data","mData","willSpiderfy","makeHighlightListenerFuncs","highlight","icon","setOptions","strokeColor","mapTypeId","zIndex","shadow","getIcon","fillOpacity","unhighlight","markerData","bodyPt","centerLl","footLl","footPt","footPts","highlightListenerFuncs","lineOrigin","md","nearestMarkerDatum","numFeet","spiderfiedMarkers","ptAverage","reverse","minExtract","Polyline","path","strokeWeight","Marker","clickable","SymbolPath","CIRCLE","fillColor","scale","hightlightListeners","setZIndex","round","markerNotToMove","unspiderfiedMarkers","pt1","pt2","dx","dy","pts","numPts","sumX","sumY","ll","set","bestIndex","bestVal","val","arr","obj","g","Function","eval","valid","infoWindow","InfoWindow","createSpiderify","_ref","spiderifyConfig","OverlappingMarkerSpiderfier","initializeSpiderify","oms","googleMarker","attachEventHandler","activeInfoWindow","close","open","Markers","_classCallCheck","markersData","Error","then","parse","_extends","parseMarkerData","filter","reduce","prev","infoWindowConfig","_toConsumableArray","clustererConfig","DEFAULTS","googleMapsConfig","gridSize","markersWontMove","markersWontHide","circleFootSeparation","nearbyDistance","keepSpiderfied","basicFormatEvents","CrowdedGoogleMap","config","src_classCallCheck","assignDeep","src_extends","initialize","container","Map"],"mappings":"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","file":"crowded-google-map.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"crowded-google-map\"] = factory();\n\telse\n\t\troot[\"crowded-google-map\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","'use strict';\n\n/*\n * OBJECT ASSIGN DEEP\n * Allows deep cloning of plain objects that contain primitives, nested plain objects, or nested plain arrays.\n */\n\n/*\n * A unified way of returning a string that describes the type of the given variable.\n */\nfunction getTypeOf (input) {\n\n\tif (input === null) {\n\t\treturn 'null';\n\t}\n\n\telse if (typeof input === 'undefined') {\n\t\treturn 'undefined';\n\t}\n\n\telse if (typeof input === 'object') {\n\t\treturn (Array.isArray(input) ? 'array' : 'object');\n\t}\n\n\treturn typeof input;\n\n}\n\n/*\n * Branching logic which calls the correct function to clone the given value base on its type.\n */\nfunction cloneValue (value) {\n\n\t// The value is an object so lets clone it.\n\tif (getTypeOf(value) === 'object') {\n\t\treturn quickCloneObject(value);\n\t}\n\n\t// The value is an array so lets clone it.\n\telse if (getTypeOf(value) === 'array') {\n\t\treturn quickCloneArray(value);\n\t}\n\n\t// Any other value can just be copied.\n\treturn value;\n\n}\n\n/*\n * Enumerates the given array and returns a new array, with each of its values cloned (i.e. references broken).\n */\nfunction quickCloneArray (input) {\n\treturn input.map(cloneValue);\n}\n\n/*\n * Enumerates the properties of the given object (ignoring the prototype chain) and returns a new object, with each of\n * its values cloned (i.e. references broken).\n */\nfunction quickCloneObject (input) {\n\n\tconst output = {};\n\n\tfor (const key in input) {\n\t\tif (!input.hasOwnProperty(key)) { continue; }\n\n\t\toutput[key] = cloneValue(input[key]);\n\t}\n\n\treturn output;\n\n}\n\n/*\n * Does the actual deep merging.\n */\nfunction executeDeepMerge (target, _objects = [], _options = {}) {\n\n\tconst options = {\n\t\tarrayBehaviour: _options.arrayBehaviour || 'replace',  // Can be \"merge\" or \"replace\".\n\t};\n\n\t// Ensure we have actual objects for each.\n\tconst objects = _objects.map(object => object || {});\n\tconst output = target || {};\n\n\t// Enumerate the objects and their keys.\n\tfor (let oindex = 0; oindex < objects.length; oindex++) {\n\t\tconst object = objects[oindex];\n\t\tconst keys = Object.keys(object);\n\n\t\tfor (let kindex = 0; kindex < keys.length; kindex++) {\n\t\t\tconst key = keys[kindex];\n\t\t\tconst value = object[key];\n\t\t\tconst type = getTypeOf(value);\n\t\t\tconst existingValueType = getTypeOf(output[key]);\n\n\t\t\tif (type === 'object') {\n\t\t\t\tif (existingValueType !== 'undefined') {\n\t\t\t\t\tconst existingValue = (existingValueType === 'object' ? output[key] : {});\n\t\t\t\t\toutput[key] = executeDeepMerge({}, [existingValue, quickCloneObject(value)], options);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[key] = quickCloneObject(value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (type === 'array') {\n\t\t\t\tif (existingValueType === 'array') {\n\t\t\t\t\tconst newValue = quickCloneArray(value);\n\t\t\t\t\toutput[key] = (options.arrayBehaviour === 'merge' ? output[key].concat(newValue) : newValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[key] = quickCloneArray(value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\toutput[key] = value;\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn output;\n\n}\n\n/*\n * Merge all the supplied objects into the target object, breaking all references, including those of nested objects\n * and arrays, and even objects nested inside arrays. The first parameter is not mutated unlike Object.assign().\n * Properties in later objects will always overwrite.\n */\nmodule.exports = function objectAssignDeep (target, ...objects) {\n\treturn executeDeepMerge(target, objects);\n};\n\n/*\n * Same as objectAssignDeep() except it doesn't mutate the target object and returns an entirely new object.\n */\nmodule.exports.noMutate = function objectAssignDeepInto (...objects) {\n\treturn executeDeepMerge({}, objects);\n};\n\n/*\n * Allows an options object to be passed in to customise the behaviour of the function.\n */\nmodule.exports.withOptions = function objectAssignDeepInto (target, objects, options) {\n\treturn executeDeepMerge(target, objects, options);\n};\n","/**\n * Npm version of markerClusterer works great with browserify and google maps for commonjs\n * https://www.npmjs.com/package/googlemaps\n * Difference from the original - adds a commonjs format and replaces window with global and some unit test\n * The original functionality it's not modified for docs and original source check\n * https://github.com/googlemaps/js-marker-clusterer\n */\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n * <br/>\n * This is a v3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >v2 MarkerClusterer</a>.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'averageCenter': (boolean) Wether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] ||\n      this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] ||\n      this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    var zoom = that.map_.getZoom();\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && opt_markers.length) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =\n    'http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/' +\n    'images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return (function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    this.pushMarkerTo_(marker);\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n   return false;\n  }\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  var removed = false;\n\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n      this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n      markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {number} The cluster center.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {Array.<google.maps.Marker>} The cluster center.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function() {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function() {\n    that.triggerClusterClick();\n  });\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n  }\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n        this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) +\n          'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n          'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n        this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) +\n          'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' +\n        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nglobal['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n    MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n    MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n    MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n    MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n    MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n    MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n    MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n    MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n    MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n    MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n    MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n    MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n    MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n    MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\n\nmodule.exports = MarkerClusterer;\n","// Generated by CoffeeScript 1.10.0\n\n/** @preserve OverlappingMarkerSpiderfier\nhttps://github.com/jawj/OverlappingMarkerSpiderfier\nCopyright (c) 2011 - 2013 George MacKerron\nReleased under the MIT licence: http://opensource.org/licenses/mit-license\nNote: The Google Maps API v3 must be included *before* this code\n */\nvar hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\nthis['OverlappingMarkerSpiderfier'] = (function() {\n  var ge, gm, lcH, lcU, mt, p, twoPi;\n\n  p = _Class.prototype;\n\n  gm = google.maps;\n\n  ge = gm.event;\n\n  mt = gm.MapTypeId;\n\n  twoPi = Math.PI * 2;\n\n  p['keepSpiderfied'] = false;\n\n  p['markersWontHide'] = false;\n\n  p['markersWontMove'] = false;\n\n  p['spiderfiedShadowColor'] = 'white';\n\n  p['nudgeStackedMarkers'] = true;\n\n  p['minNudgeZoomLevel'] = 8;\n\n  p['nudgeRadius'] = 1;\n\n  p['markerCountInBaseNudgeLevel'] = 9;\n\n  p['maxNudgeCount'] = 9;\n\n  p['nudgeBucketSize'] = 12;\n\n  p['nearbyDistance'] = 20;\n\n  p['circleSpiralSwitchover'] = 9;\n\n  p['circleFootSeparation'] = 23;\n\n  p['circleStartAngle'] = twoPi / 12;\n\n  p['spiralFootSeparation'] = 26;\n\n  p['spiralLengthStart'] = 11;\n\n  p['spiralLengthFactor'] = 4;\n\n  p['spiderfiedZIndex'] = 1000;\n\n  p['usualLegZIndex'] = 10;\n\n  p['highlightedLegZIndex'] = 20;\n\n  p['event'] = 'click';\n\n  p['minZoomLevel'] = false;\n\n  p['lineToCenter'] = true;\n\n  p['legWeight'] = 1.5;\n\n  p['legColors'] = {\n    'usual': {},\n    'highlighted': {}\n  };\n\n  lcU = p['legColors']['usual'];\n\n  lcH = p['legColors']['highlighted'];\n\n  lcU[mt.HYBRID] = lcU[mt.SATELLITE] = '#fff';\n\n  lcH[mt.HYBRID] = lcH[mt.SATELLITE] = '#f00';\n\n  lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = '#444';\n\n  lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = '#f00';\n\n  function _Class(map1, opts) {\n    var e, j, k, len, ref, v;\n    this.map = map1;\n    if (opts == null) {\n      opts = {};\n    }\n    for (k in opts) {\n      if (!hasProp.call(opts, k)) continue;\n      v = opts[k];\n      this[k] = v;\n    }\n    this.projHelper = new this.constructor.ProjHelper(this.map);\n    this.initMarkerArrays();\n    this.listeners = {};\n    ref = ['click', 'zoom_changed', 'maptypeid_changed'];\n    for (j = 0, len = ref.length; j < len; j++) {\n      e = ref[j];\n      ge.addListener(this.map, e, (function(_this) {\n        return function() {\n          return _this['unspiderfy']();\n        };\n      })(this));\n    }\n    if (this['nudgeStackedMarkers']) {\n      ge.addListenerOnce(this.map, 'idle', (function(_this) {\n        return function() {\n          ge.addListener(_this.map, 'zoom_changed', function() {\n            return _this.mapZoomChangeListener();\n          });\n          return _this.mapZoomChangeListener();\n        };\n      })(this));\n    }\n  }\n\n  p.initMarkerArrays = function() {\n    this.markers = [];\n    return this.markerListenerRefs = [];\n  };\n\n  p['addMarker'] = function(marker) {\n    var listenerRefs;\n    if (marker['_oms'] != null) {\n      return this;\n    }\n    marker['_oms'] = true;\n    listenerRefs = [\n      ge.addListener(marker, this['event'], (function(_this) {\n        return function(event) {\n          return _this.spiderListener(marker, event);\n        };\n      })(this))\n    ];\n    if (!this['markersWontHide']) {\n      listenerRefs.push(ge.addListener(marker, 'visible_changed', (function(_this) {\n        return function() {\n          return _this.markerChangeListener(marker, false);\n        };\n      })(this)));\n    }\n    if (!this['markersWontMove']) {\n      listenerRefs.push(ge.addListener(marker, 'position_changed', (function(_this) {\n        return function() {\n          return _this.markerChangeListener(marker, true);\n        };\n      })(this)));\n    }\n    this.markerListenerRefs.push(listenerRefs);\n    this.markers.push(marker);\n    if (this.isNudgingActive()) {\n      this.requestNudge();\n    }\n    return this;\n  };\n\n  p.nudgeTimeout = null;\n\n  p.requestNudge = function() {\n    if (this.nudgeTimeout) {\n      clearTimeout(this.nudgeTimeout);\n    }\n    return this.nudgeTimeout = setTimeout((function(_this) {\n      return function() {\n        return _this.nudgeAllMarkers();\n      };\n    })(this), 10);\n  };\n\n  p.isNudgingActive = function() {\n    return this['nudgeStackedMarkers'] && !(this['minNudgeZoomLevel'] && this.map.getZoom() < this['minNudgeZoomLevel']) && !this.spiderfied;\n  };\n\n  p.markerChangeListener = function(marker, positionChanged) {\n    if ((marker['_omsData'] != null) && marker['_omsData'].leg && (positionChanged || !marker.getVisible()) && !((this.spiderfying != null) || (this.unspiderfying != null))) {\n      return this['unspiderfy'](positionChanged ? marker : null);\n    }\n  };\n\n  p.countsPerLevel = [1, 1];\n\n  p.levelsByCount = [];\n\n  p.getCountPerNudgeLevel = function(level) {\n    if (this.countsPerLevel[level] != null) {\n      return this.countsPerLevel[level];\n    }\n    this.countsPerLevel[level] = this.getCountPerNudgeLevel(level - 1) + Math.pow(2, level - 2) * this['markerCountInBaseNudgeLevel'];\n    return this.countsPerLevel[level];\n  };\n\n  p.getNudgeLevel = function(markerIndex) {\n    var level;\n    if (this.levelsByCount[markerIndex] != null) {\n      return this.levelsByCount[markerIndex];\n    }\n    level = 0;\n    while (markerIndex >= this.countsPerLevel[level]) {\n      if (level + 1 >= this.countsPerLevel.length) {\n        this.getCountPerNudgeLevel(level + 1);\n      }\n      level++;\n    }\n    this.levelsByCount[markerIndex] = level - 1;\n    return this.levelsByCount[markerIndex];\n  };\n\n  p.nudgeAllMarkers = function() {\n    var bucketSize, changeX, changeY, changesX, changesY, count, getHash, j, len, m, needsNudge, originalPos, pos, posHash, positions, ref, ref1, ref2, ref3, ref4, ref5, results, ringLevel;\n    if (!this.isNudgingActive()) {\n      return;\n    }\n    positions = {};\n    changesX = [];\n    changesY = [];\n    bucketSize = 1 / ((1 + this['nudgeBucketSize']) * this['nudgeRadius']);\n    getHash = (function(_this) {\n      return function(pos) {\n        return Math.floor(pos.x * bucketSize) + ',' + Math.floor(pos.y * bucketSize);\n      };\n    })(this);\n    ref = this.markers;\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n      m = ref[j];\n      needsNudge = false;\n      pos = this.llToPt((ref1 = (ref2 = m['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : m.position);\n      originalPos = {\n        x: pos.x,\n        y: pos.y\n      };\n      posHash = getHash(pos);\n      while ((positions[posHash] != null) && ((this['maxNudgeCount'] == null) || positions[posHash] <= this['maxNudgeCount'])) {\n        count = positions[posHash];\n        positions[posHash] += 1;\n        if (changesX[count] != null) {\n          changeX = changesX[count];\n          changeY = changesY[count];\n        } else {\n          ringLevel = this.getNudgeLevel(count);\n          changesX[count] = changeX = Math.sin(twoPi * count / this['markerCountInBaseNudgeLevel'] / ringLevel) * 20 * this['nudgeRadius'] * ringLevel;\n          changesY[count] = changeY = Math.cos(twoPi * count / this['markerCountInBaseNudgeLevel'] / ringLevel) * 20 * this['nudgeRadius'] * ringLevel;\n        }\n        pos.x = originalPos.x + changeX;\n        pos.y = originalPos.y + changeY;\n        this.nudged = true;\n        needsNudge = true;\n        posHash = getHash(pos);\n      }\n      if (needsNudge) {\n        m['_omsData'] = (ref3 = m['_omsData']) != null ? ref3 : {};\n        m['_omsData'].usualPosition = (ref4 = (ref5 = m['_omsData']) != null ? ref5.usualPosition : void 0) != null ? ref4 : m.position;\n        m.setPosition(this.ptToLl(pos));\n      } else if ((m['_omsData'] != null) && (m['_omsData'].leg == null)) {\n        m.setPosition(m['_omsData'].usualPosition);\n        delete m['_omsData'];\n      }\n      if (!(posHash in positions)) {\n        results.push(positions[posHash] = 1);\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  p.resetNudgedMarkers = function() {\n    var j, len, m, ref;\n    if (!this.nudged) {\n      return;\n    }\n    ref = this.markers;\n    for (j = 0, len = ref.length; j < len; j++) {\n      m = ref[j];\n      if ((m['_omsData'] != null) && (m['_omsData'].leg == null)) {\n        m.setPosition(m['_omsData'].usualPosition);\n        delete m['_omsData'];\n      }\n    }\n    return delete this.nudged;\n  };\n\n  p.mapZoomChangeListener = function() {\n    if (this['minNudgeZoomLevel'] && this.map.getZoom() < this['minNudgeZoomLevel']) {\n      return this.resetNudgedMarkers();\n    }\n    return this.requestNudge();\n  };\n\n  p['getMarkers'] = function() {\n    return this.markers.slice(0);\n  };\n\n  p['removeMarker'] = function(marker) {\n    var i, j, len, listenerRef, listenerRefs;\n    if (marker['_omsData'] != null) {\n      this['unspiderfy']();\n    }\n    i = this.arrIndexOf(this.markers, marker);\n    if (i < 0) {\n      return this;\n    }\n    listenerRefs = this.markerListenerRefs.splice(i, 1)[0];\n    for (j = 0, len = listenerRefs.length; j < len; j++) {\n      listenerRef = listenerRefs[j];\n      ge.removeListener(listenerRef);\n    }\n    delete marker['_oms'];\n    this.markers.splice(i, 1);\n    if (this.isNudgingActive()) {\n      this.requestNudge();\n    }\n    return this;\n  };\n\n  p['clearMarkers'] = function() {\n    var i, j, l, len, len1, listenerRef, listenerRefs, marker, ref;\n    this['unspiderfy']();\n    ref = this.markers;\n    for (i = j = 0, len = ref.length; j < len; i = ++j) {\n      marker = ref[i];\n      listenerRefs = this.markerListenerRefs[i];\n      for (l = 0, len1 = listenerRefs.length; l < len1; l++) {\n        listenerRef = listenerRefs[l];\n        ge.removeListener(listenerRef);\n      }\n      delete marker['_oms'];\n    }\n    this.initMarkerArrays();\n    return this;\n  };\n\n  p['addListener'] = function(event, func) {\n    var base;\n    ((base = this.listeners)[event] != null ? base[event] : base[event] = []).push(func);\n    return this;\n  };\n\n  p['removeListener'] = function(event, func) {\n    var i;\n    i = this.arrIndexOf(this.listeners[event], func);\n    if (!(i < 0)) {\n      this.listeners[event].splice(i, 1);\n    }\n    return this;\n  };\n\n  p['clearListeners'] = function(event) {\n    this.listeners[event] = [];\n    return this;\n  };\n\n  p.trigger = function() {\n    var args, event, func, j, len, ref, ref1, results;\n    event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    ref1 = (ref = this.listeners[event]) != null ? ref : [];\n    results = [];\n    for (j = 0, len = ref1.length; j < len; j++) {\n      func = ref1[j];\n      results.push(func.apply(null, args));\n    }\n    return results;\n  };\n\n  p.generatePtsCircle = function(count, centerPt) {\n    var angle, angleStep, circumference, i, j, legLength, ref, results;\n    circumference = this['circleFootSeparation'] * (2 + count);\n    legLength = circumference / twoPi;\n    angleStep = twoPi / count;\n    results = [];\n    for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      angle = this['circleStartAngle'] + i * angleStep;\n      results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));\n    }\n    return results;\n  };\n\n  p.generatePtsSpiral = function(count, centerPt) {\n    var angle, i, j, legLength, pt, ref, results;\n    legLength = this['spiralLengthStart'];\n    angle = 0;\n    results = [];\n    for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      angle += this['spiralFootSeparation'] / legLength + i * 0.0005;\n      pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));\n      legLength += twoPi * this['spiralLengthFactor'] / angle;\n      results.push(pt);\n    }\n    return results;\n  };\n\n  p.spiderListener = function(marker, event) {\n    var j, len, m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, ref;\n    markerSpiderfied = (marker['_omsData'] != null) && (marker['_omsData'].leg != null);\n    if (!(markerSpiderfied && this['keepSpiderfied'])) {\n      if (this['event'] === 'mouseover') {\n        window.clearTimeout(p.timeout);\n        p.timeout = setTimeout((function(_this) {\n          return function() {\n            return _this['unspiderfy']();\n          };\n        })(this), 3000);\n      } else {\n        this['unspiderfy']();\n      }\n    }\n    if (markerSpiderfied || this.map.getStreetView().getVisible() || this.map.getMapTypeId() === 'GoogleEarthAPI' || this['minZoomLevel'] && this.map.getZoom() < this['minZoomLevel']) {\n      return this.trigger('click', marker, event);\n    } else {\n      nearbyMarkerData = [];\n      nonNearbyMarkers = [];\n      nDist = this['nearbyDistance'];\n      pxSq = nDist * nDist;\n      markerPt = this.llToPt(marker.position);\n      ref = this.markers;\n      for (j = 0, len = ref.length; j < len; j++) {\n        m = ref[j];\n        if (!((m.map != null) && m.getVisible())) {\n          continue;\n        }\n        mPt = this.llToPt(m.position);\n        if (this.ptDistanceSq(mPt, markerPt) < pxSq) {\n          nearbyMarkerData.push({\n            marker: m,\n            markerPt: mPt\n          });\n        } else {\n          nonNearbyMarkers.push(m);\n        }\n      }\n      if (nearbyMarkerData.length === 1) {\n        return this.trigger('click', marker, event);\n      } else {\n        return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);\n      }\n    }\n  };\n\n  p['markersNearMarker'] = function(marker, firstOnly) {\n    var j, len, m, mPt, markerPt, markers, nDist, pxSq, ref, ref1, ref2;\n    if (firstOnly == null) {\n      firstOnly = false;\n    }\n    if (this.projHelper.getProjection() == null) {\n      throw \"Must wait for 'idle' event on map before calling markersNearMarker\";\n    }\n    nDist = this['nearbyDistance'];\n    pxSq = nDist * nDist;\n    markerPt = this.llToPt(marker.position);\n    markers = [];\n    ref = this.markers;\n    for (j = 0, len = ref.length; j < len; j++) {\n      m = ref[j];\n      if (m === marker || (m.map == null) || !m.getVisible()) {\n        continue;\n      }\n      mPt = this.llToPt((ref1 = (ref2 = m['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : m.position);\n      if (this.ptDistanceSq(mPt, markerPt) < pxSq) {\n        markers.push(m);\n        if (firstOnly) {\n          break;\n        }\n      }\n    }\n    return markers;\n  };\n\n  p['markersNearAnyOtherMarker'] = function() {\n    var i, i1, i2, j, l, len, len1, len2, m, m1, m1Data, m2, m2Data, mData, n, nDist, pxSq, ref, ref1, ref2, results;\n    if (this.projHelper.getProjection() == null) {\n      throw \"Must wait for 'idle' event on map before calling markersNearAnyOtherMarker\";\n    }\n    nDist = this['nearbyDistance'];\n    pxSq = nDist * nDist;\n    mData = (function() {\n      var j, len, ref, ref1, ref2, results;\n      ref = this.markers;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        m = ref[j];\n        results.push({\n          pt: this.llToPt((ref1 = (ref2 = m['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : m.position),\n          willSpiderfy: false\n        });\n      }\n      return results;\n    }).call(this);\n    ref = this.markers;\n    for (i1 = j = 0, len = ref.length; j < len; i1 = ++j) {\n      m1 = ref[i1];\n      if (!((m1.map != null) && m1.getVisible())) {\n        continue;\n      }\n      m1Data = mData[i1];\n      if (m1Data.willSpiderfy) {\n        continue;\n      }\n      ref1 = this.markers;\n      for (i2 = l = 0, len1 = ref1.length; l < len1; i2 = ++l) {\n        m2 = ref1[i2];\n        if (i2 === i1) {\n          continue;\n        }\n        if (!((m2.map != null) && m2.getVisible())) {\n          continue;\n        }\n        m2Data = mData[i2];\n        if (i2 < i1 && !m2Data.willSpiderfy) {\n          continue;\n        }\n        if (this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {\n          m1Data.willSpiderfy = m2Data.willSpiderfy = true;\n          break;\n        }\n      }\n    }\n    ref2 = this.markers;\n    results = [];\n    for (i = n = 0, len2 = ref2.length; n < len2; i = ++n) {\n      m = ref2[i];\n      if (mData[i].willSpiderfy) {\n        results.push(m);\n      }\n    }\n    return results;\n  };\n\n  p.makeHighlightListenerFuncs = function(marker) {\n    return {\n      highlight: (function(_this) {\n        return function() {\n          var icon;\n          marker['_omsData'].leg.setOptions({\n            strokeColor: _this['legColors']['highlighted'][_this.map.mapTypeId],\n            zIndex: _this['highlightedLegZIndex']\n          });\n          if (marker['_omsData'].shadow != null) {\n            icon = marker['_omsData'].shadow.getIcon();\n            icon.fillOpacity = 0.8;\n            return marker['_omsData'].shadow.setOptions({\n              icon: icon\n            });\n          }\n        };\n      })(this),\n      unhighlight: (function(_this) {\n        return function() {\n          var icon;\n          marker['_omsData'].leg.setOptions({\n            strokeColor: _this['legColors']['usual'][_this.map.mapTypeId],\n            zIndex: _this['usualLegZIndex']\n          });\n          if (marker['_omsData'].shadow != null) {\n            icon = marker['_omsData'].shadow.getIcon();\n            icon.fillOpacity = 0.3;\n            return marker['_omsData'].shadow.setOptions({\n              icon: icon\n            });\n          }\n        };\n      })(this)\n    };\n  };\n\n  p.spiderfy = function(markerData, nonNearbyMarkers) {\n    var bodyPt, centerLl, footLl, footPt, footPts, highlightListenerFuncs, leg, lineOrigin, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;\n    this.spiderfying = true;\n    numFeet = markerData.length;\n    bodyPt = this.ptAverage((function() {\n      var j, len, results;\n      results = [];\n      for (j = 0, len = markerData.length; j < len; j++) {\n        md = markerData[j];\n        results.push(md.markerPt);\n      }\n      return results;\n    })());\n    footPts = numFeet >= this['circleSpiralSwitchover'] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);\n    centerLl = this.ptToLl(bodyPt);\n    spiderfiedMarkers = (function() {\n      var j, len, ref, ref1, ref2, results;\n      results = [];\n      for (j = 0, len = footPts.length; j < len; j++) {\n        footPt = footPts[j];\n        footLl = this.ptToLl(footPt);\n        nearestMarkerDatum = this.minExtract(markerData, (function(_this) {\n          return function(md) {\n            return _this.ptDistanceSq(md.markerPt, footPt);\n          };\n        })(this));\n        marker = nearestMarkerDatum.marker;\n        lineOrigin = this['lineToCenter'] ? centerLl : marker.position;\n        leg = new gm.Polyline({\n          map: this.map,\n          path: [lineOrigin, footLl],\n          strokeColor: this['legColors']['usual'][this.map.mapTypeId],\n          strokeWeight: this['legWeight'],\n          zIndex: this['usualLegZIndex']\n        });\n        marker['_omsData'] = (ref = marker['_omsData']) != null ? ref : {};\n        marker['_omsData'].usualPosition = (ref1 = (ref2 = marker['_omsData']) != null ? ref2.usualPosition : void 0) != null ? ref1 : marker.position;\n        marker['_omsData'].leg = leg;\n        if (this['spiderfiedShadowColor']) {\n          marker['_omsData'].shadow = new gm.Marker({\n            position: footLl,\n            map: this.map,\n            clickable: false,\n            zIndex: -2,\n            icon: {\n              path: google.maps.SymbolPath.CIRCLE,\n              fillOpacity: 0.3,\n              fillColor: this['spiderfiedShadowColor'],\n              strokeWeight: 0,\n              scale: 20\n            }\n          });\n        }\n        if (this['legColors']['highlighted'][this.map.mapTypeId] !== this['legColors']['usual'][this.map.mapTypeId]) {\n          highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);\n          marker['_omsData'].hightlightListeners = {\n            highlight: ge.addListener(marker, 'mouseover', highlightListenerFuncs.highlight),\n            unhighlight: ge.addListener(marker, 'mouseout', highlightListenerFuncs.unhighlight)\n          };\n        }\n        marker.setPosition(footLl);\n        marker.setZIndex(Math.round(this['spiderfiedZIndex'] + footPt.y));\n        results.push(marker);\n      }\n      return results;\n    }).call(this);\n    delete this.spiderfying;\n    this.spiderfied = true;\n    return this.trigger('spiderfy', spiderfiedMarkers, nonNearbyMarkers);\n  };\n\n  p['unspiderfy'] = function(markerNotToMove) {\n    var j, len, listeners, marker, nonNearbyMarkers, ref, ref1, unspiderfiedMarkers;\n    if (markerNotToMove == null) {\n      markerNotToMove = null;\n    }\n    if (!((this.spiderfied != null) || (this.nudged != null))) {\n      return this;\n    }\n    this.unspiderfying = true;\n    unspiderfiedMarkers = [];\n    nonNearbyMarkers = [];\n    ref = this.markers;\n    for (j = 0, len = ref.length; j < len; j++) {\n      marker = ref[j];\n      if ((marker['_omsData'] != null) && (marker['_omsData'].leg != null)) {\n        marker['_omsData'].leg.setMap(null);\n        if ((ref1 = marker['_omsData'].shadow) != null) {\n          ref1.setMap(null);\n        }\n        if (marker !== markerNotToMove) {\n          marker.setPosition(marker['_omsData'].usualPosition);\n        }\n        marker.setZIndex(null);\n        listeners = marker['_omsData'].hightlightListeners;\n        if (listeners != null) {\n          ge.removeListener(listeners.highlight);\n          ge.removeListener(listeners.unhighlight);\n        }\n        delete marker['_omsData'];\n        unspiderfiedMarkers.push(marker);\n      } else {\n        nonNearbyMarkers.push(marker);\n      }\n    }\n    delete this.unspiderfying;\n    delete this.spiderfied;\n    this.trigger('unspiderfy', unspiderfiedMarkers, nonNearbyMarkers);\n    if (this.nudged) {\n      this.requestNudge();\n    }\n    return this;\n  };\n\n  p.ptDistanceSq = function(pt1, pt2) {\n    var dx, dy;\n    dx = pt1.x - pt2.x;\n    dy = pt1.y - pt2.y;\n    return dx * dx + dy * dy;\n  };\n\n  p.ptAverage = function(pts) {\n    var j, len, numPts, pt, sumX, sumY;\n    sumX = sumY = 0;\n    for (j = 0, len = pts.length; j < len; j++) {\n      pt = pts[j];\n      sumX += pt.x;\n      sumY += pt.y;\n    }\n    numPts = pts.length;\n    return new gm.Point(sumX / numPts, sumY / numPts);\n  };\n\n  p.llToPt = function(ll) {\n    return this.projHelper.getProjection().fromLatLngToDivPixel(ll);\n  };\n\n  p.ptToLl = function(pt) {\n    return this.projHelper.getProjection().fromDivPixelToLatLng(pt);\n  };\n\n  p.minExtract = function(set, func) {\n    var bestIndex, bestVal, index, item, j, len, val;\n    for (index = j = 0, len = set.length; j < len; index = ++j) {\n      item = set[index];\n      val = func(item);\n      if ((typeof bestIndex === \"undefined\" || bestIndex === null) || val < bestVal) {\n        bestVal = val;\n        bestIndex = index;\n      }\n    }\n    return set.splice(bestIndex, 1)[0];\n  };\n\n  p.arrIndexOf = function(arr, obj) {\n    var i, j, len, o;\n    if (arr.indexOf != null) {\n      return arr.indexOf(obj);\n    }\n    for (i = j = 0, len = arr.length; j < len; i = ++j) {\n      o = arr[i];\n      if (o === obj) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  _Class.ProjHelper = function(map) {\n    return this.setMap(map);\n  };\n\n  _Class.ProjHelper.prototype = new gm.OverlayView();\n\n  _Class.ProjHelper.prototype['draw'] = function() {};\n\n  return _Class;\n\n})();\n\nmodule.exports = this['OverlappingMarkerSpiderfier'];\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import OverlappingMarkerSpiderfier from 'overlapping-marker-spiderfier';\n\nconst Marker = {\n  valid: marker =>\n    marker.position && typeof marker.position.lat === 'number' && typeof marker.position.lng === 'number',\n  create: marker => new google.maps.Marker(marker),\n  infoWindow: opts => new google.maps.InfoWindow(opts),\n  createSpiderify: ({ map, spiderifyConfig }) => new OverlappingMarkerSpiderfier(map, spiderifyConfig),\n  initializeSpiderify: (oms, googleMarker) => oms.addMarker(googleMarker),\n  attachEventHandler: (googleMarker, infoWindow, map) => {\n    googleMarker.addListener('click', () => {\n      map.activeInfoWindow.close();\n      map.activeInfoWindow = infoWindow; // mutating state, kind of bad\n      infoWindow.open(map, googleMarker);\n    });\n  }\n};\n\nexport default Marker;\n","import MarkerClusterer from 'node-js-marker-clusterer';\nimport Marker from './marker';\n\nclass Markers {\n  constructor(opts) {\n    if (!opts || !opts.markersData || !opts.map) {\n      throw new Error('CrowdedGoogleMap :: Some required options are missing');\n      return;\n    }\n\n    this.get(opts)\n      .then(this.parse)\n      // .then(this.waitForMap)\n      .then(this.create)\n      .then(this.cluster);\n  }\n\n  get(opts) {\n    return opts.markersData.then(markers => {\n      return Object.assign({}, opts, {\n        markersData: markers\n      });\n    });\n  }\n\n  parse(opts) {\n    return Object.assign({}, opts, {\n      markersData: opts.markersData.map(opts.parseMarkerData)\n    });\n  }\n\n  // waitForMap(opts) {\n  // const isInitialized = opts => typeof opts.map.getProjection() === 'object';\n\n  // return new Promise(resolve => {\n  // const resolveIfReady = () => {\n  //   if (isInitialized(opts)) {\n  //     resolve(opts);\n  //   } else {\n  //     requestAnimationFrame(resolveIfReady);\n  //   }\n  // };\n\n  // requestAnimationFrame(resolveIfReady);\n  // });\n  // }\n\n  create(opts) {\n    const oms = Marker.createSpiderify(opts);\n\n    return Object.assign({}, opts, {\n      markersData: opts.markersData.filter(Marker.valid).reduce((prev, marker) => {\n        const googleMarker = Marker.create(marker);\n        const infoWindowConfig = opts.infoWindowConfig(marker);\n        const infoWindow = Marker.infoWindow(infoWindowConfig);\n\n        Marker.attachEventHandler(googleMarker, infoWindow, opts.map);\n        Marker.initializeSpiderify(oms, googleMarker);\n\n        return [...prev, googleMarker];\n      }, [])\n    });\n  }\n\n  cluster({ map, markersData, clustererConfig }) {\n    return new MarkerClusterer(map, markersData, clustererConfig);\n  }\n}\n\nexport default Markers;\n","import assignDeep from 'object-assign-deep';\n\nimport GoogleMapsDefaults from './config/google-maps';\nimport omsDefaults from './config/overlapping-marker-spiderifier';\nimport MarkerClustererDefaults from './config/marker-clusterer';\n\nimport Markers from './Markers';\n\nconst DEFAULTS = {\n  googleMapsConfig: GoogleMapsDefaults,\n  clustererConfig: MarkerClustererDefaults,\n  spiderifyConfig: omsDefaults,\n  activeInfoWindow: {\n    close: () => {}\n  },\n  markersData: [],\n  infoWindowConfig: m => m,\n  parseMarkerData: m => m\n};\n\nclass CrowdedGoogleMap {\n  constructor(config) {\n    const opts = assignDeep({}, DEFAULTS, config);\n    const options = Object.assign({}, opts, {\n      map: this.initialize(config.container, opts),\n      markersData: config.markersData\n    });\n\n    new Markers(options);\n  }\n\n  initialize(container, { googleMapsConfig, activeInfoWindow }) {\n    return new google.maps.Map(container, {\n      center: googleMapsConfig.center,\n      zoom: googleMapsConfig.zoom,\n      activeInfoWindow: activeInfoWindow\n    });\n  }\n}\n\nwindow.CrowdedGoogleMap = CrowdedGoogleMap;\n\nexport default CrowdedGoogleMap;\n","export default {\n  center: { lat: -25.363, lng: 131.044 },\n  zoom: 5\n};\n","export default {\n  gridSize: 50,\n  maxZoom: 14\n};\n","export default {\n  markersWontMove: true,\n  markersWontHide: true,\n  circleFootSeparation: 60,\n  nearbyDistance: 60,\n  keepSpiderfied: true,\n  basicFormatEvents: true\n};\n"],"sourceRoot":""}